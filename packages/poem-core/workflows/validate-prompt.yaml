# Validate Prompt Workflow
# Validates prompt structure, schema alignment, helper registration, and best practices
#
# Executed by: Prompt Engineer agent (Penny) via *validate command
# Execution model: Agent-interpreted (steps guide agent behavior, not automated)
#
# Path resolution: Inherited from poem-core-config.yaml
# DO NOT add a paths: section - config service is the source of truth
# See: packages/poem-core/workflows/README.md for the pattern

id: validate-prompt
name: Validate Prompt Structure and Quality
version: "1.0.0"
author: POEM Framework
lastUpdated: "2026-01-11"

# Path resolution mode - indicates this workflow uses config for paths
pathResolution: config

description: |
  Validates Handlebars prompt templates for structural correctness and quality:
  - Validate Handlebars syntax (no parse errors)
  - Validate schema alignment (input/output placeholders match schemas)
  - Validate required helpers are registered
  - Check POEM best practices (configurable rules)
  - Report issues with severity levels (error, warning, info)
  - Provide fix suggestions for common issues

  Follows BMAD elicitation patterns for user interaction.

  **Path Resolution:**
  Workspace paths are inherited from poem-core-config.yaml (loaded by config service).
  - Development (POEM_DEV=true): dev-workspace/prompts/, dev-workspace/schemas/, etc.
  - Production: poem/prompts/, poem/schemas/, etc.
  The agent detects mode by checking for packages/poem-core/ (dev) vs .poem-core/ (prod).

# Error handling defaults
fallback:
  onMissingInput: prompt-again
  onApiError: show-error-and-retry
  onFileConflict: warn-and-confirm

steps:
  # ============================================================================
  # STEP 1: Select Prompt to Validate (Elicitation)
  # ============================================================================
  - id: select-prompt
    name: Select Prompt to Validate
    type: elicit
    elicit: true
    prompt: |
      Which prompt would you like to validate?

      **Options:**
      1. Enter the prompt name (e.g., `generate-titles`)
      2. Enter the full path to the template file

      **Note:** The prompt should exist in your workspace:
      - Development mode: `dev-workspace/prompts/`
      - Production mode: `poem/prompts/`

      ---
      Enter prompt name or path:
    validation:
      required: true
      minLength: 1
    stores: promptName
    instruction: |
      Wait for user to provide prompt name or path.

      1. **Parse input:**
         - If input contains `.hbs` extension, treat as full path
         - Otherwise, treat as prompt name (e.g., "generate-titles")

      2. **Detect workspace mode:**
         - Check if `packages/poem-core/` exists → Development mode
         - Otherwise → Production mode

      3. **Build file path:**
         - Development: `dev-workspace/prompts/{promptName}.hbs`
         - Production: `poem/prompts/{promptName}.hbs`
         - If full path provided, use as-is

      4. **Validate file exists:**
         - Read file to verify it exists
         - If not found, display error:
           "Prompt not found: {expectedPath}"
           "Available prompts: [list .hbs files in prompts directory]"
           Prompt user again

      5. **Store results:**
         - `promptPath`: Full path to template file
         - `promptName`: Base name without extension
         - `workspaceMode`: "development" or "production"

  # ============================================================================
  # STEP 2: Load Prompt Template (Action)
  # ============================================================================
  - id: load-template
    name: Load Prompt Template
    type: action
    instruction: |
      Load the template file from the workspace.

      1. **Read template file:**
         - Use promptPath from previous step
         - Read file content into templateContent variable

      2. **Calculate template metadata:**
         - File size in bytes
         - Line count
         - Character count

      3. **Display to user:**
         - "Loading template: {promptPath}"
         - "Template size: {size} bytes, {lineCount} lines"

      4. **Store results:**
         - `templateContent`: Full template text
         - `templateSize`: File size in bytes
         - `templateLineCount`: Number of lines

  # ============================================================================
  # STEP 3: Validate Handlebars Syntax (Action)
  # ============================================================================
  - id: validate-syntax
    name: Validate Handlebars Syntax
    type: action
    instruction: |
      Validate template syntax using Handlebars.compile().

      1. **Attempt compilation:**
         - Try: `Handlebars.compile(templateContent)`
         - If successful: No syntax errors
         - If exception: Capture error message and line number if available

      2. **Parse error details:**
         - Extract error type (e.g., "Parse error", "Missing closing brace")
         - Extract line number if present
         - Extract column number if present

      3. **Report results:**
         - If valid: Display "✓ Syntax validation passed"
         - If errors: Display "✗ Syntax errors detected:"
           - List each error with line/column if available
           - Severity: error

      4. **Store results:**
         - `syntaxValid`: boolean (true/false)
         - `syntaxErrors`: array of {message, line?, column?, severity: "error"}

  # ============================================================================
  # STEP 4: Extract Template Placeholders and Helpers (Action)
  # ============================================================================
  - id: extract-placeholders
    name: Extract Placeholders and Helpers
    type: action
    instruction: |
      Call schema extraction API to identify placeholders and helpers.

      1. **Call API:**
         - Endpoint: POST /api/schema/extract
         - Request: {template: templateContent, isRawTemplate: true}
         - Capture response: {schema, requiredHelpers, templatePath}

      2. **Parse extracted schema:**
         - Extract placeholder names from schema object
         - Count total placeholders
         - Identify nested placeholders (e.g., user.name)

      3. **Parse required helpers:**
         - Extract helper names from requiredHelpers array
         - Count total helpers used

      4. **Display to user:**
         - "Placeholders found: {count}"
         - List placeholder names (first 10 if many)
         - "Helpers used: {count}"
         - List helper names

      5. **Store results:**
         - `extractedSchema`: Schema object from API
         - `requiredHelpers`: Array of helper names
         - `placeholderCount`: Number of placeholders

  # ============================================================================
  # STEP 5: Load Input and Output Schemas (Action)
  # ============================================================================
  - id: load-schemas
    name: Load Input and Output Schemas
    type: action
    instruction: |
      Load input and output schema files if they exist.

      1. **Detect workspace mode and build schema paths:**
         - Development: `dev-workspace/schemas/{promptName}.json` (input)
         - Development: `dev-workspace/schemas/{promptName}-output.json` (output)
         - Production: `poem/schemas/{promptName}.json` (input)
         - Production: `poem/schemas/{promptName}-output.json` (output)

      2. **Load input schema:**
         - Check if file exists
         - If exists: Read and parse JSON, store in inputSchemaContent
         - If not exists: Set inputSchemaContent = null

      3. **Load output schema:**
         - Check if file exists
         - If exists: Read and parse JSON, store in outputSchemaContent
         - If not exists: Set outputSchemaContent = null

      4. **Display to user:**
         - If input schema found: "✓ Input schema found: {path}"
         - If input schema missing: "⚠ Input schema not found (validation will be skipped)"
         - If output schema found: "✓ Output schema found: {path}"
         - If output schema missing: "ℹ Output schema not found (optional)"

      5. **Store results:**
         - `inputSchemaContent`: Schema JSON or null
         - `outputSchemaContent`: Schema JSON or null
         - `hasInputSchema`: boolean
         - `hasOutputSchema`: boolean

  # ============================================================================
  # STEP 6: Validate Placeholders Against Input Schema (Action)
  # ============================================================================
  - id: validate-input-schema
    name: Validate Input Schema Alignment
    type: action
    instruction: |
      Compare template placeholders with input schema fields.

      **Only execute if hasInputSchema is true. Otherwise skip.**

      1. **Extract schema field names:**
         - Parse inputSchemaContent to get all property names
         - Support nested properties (e.g., user.name → user, user.name)
         - Flatten schema to list of all valid field paths

      2. **Compare placeholders vs schema:**
         - For each placeholder in extractedSchema:
           - Check if placeholder exists in schema fields
           - If not found: Add to missingSchemaFields array with severity "error"
         - For each schema field:
           - Check if field is used in any placeholder
           - If not used: Add to unusedSchemaFields array with severity "warning"

      3. **Generate suggestions:**
         - For missing fields: "Add '{fieldName}' to input schema"
         - For unused fields: "Remove '{fieldName}' from schema or use in template"

      4. **Display results:**
         - If no issues: "✓ Input schema validation passed"
         - If issues: "✗ Input schema issues detected:"
           - "Missing schema fields ({count}):" → list errors
           - "Unused schema fields ({count}):" → list warnings

      5. **Store results:**
         - `inputSchemaIssues`: array of {field, message, severity: "error"|"warning", suggestion}

      **If inputSchemaContent is null:**
      - Display: "ℹ Input schema validation skipped (no schema file)"
      - Set inputSchemaIssues = []

  # ============================================================================
  # STEP 7: Validate Output Schema Against Template (Action)
  # ============================================================================
  - id: validate-output-schema
    name: Validate Output Schema Alignment
    type: action
    instruction: |
      Verify output schema matches "Expected Output" section in template.

      **Only execute if hasOutputSchema is true. Otherwise skip.**

      1. **Extract output definition from template:**
         - Search for HTML comments: <!-- Expected Output: ... -->
         - Search for Handlebars comments: {{! Output Format: ... }}
         - Extract structure definition from comment content

      2. **Compare output schema fields with template definition:**
         - Parse field names from outputSchemaContent
         - Parse field names from template's Expected Output section
         - Check for mismatches:
           - Fields in schema but not in template definition
           - Fields in template definition but not in schema

      3. **Generate validation results:**
         - If schema and template match: Add to validations "✓ Output schema matches template"
         - If mismatches found: Add warnings for each mismatch
           - "Output schema field '{field}' not mentioned in Expected Output section"
           - "Template specifies '{field}' but not in output schema"

      4. **Display results:**
         - If no issues: "✓ Output schema validation passed"
         - If issues: "⚠ Output schema issues detected:" → list warnings

      5. **Store results:**
         - `outputSchemaIssues`: array of {field, message, severity: "warning", suggestion}

      **If outputSchemaContent is null:**
      - Display: "ℹ Output schema validation skipped (no output schema file - optional)"
      - Set outputSchemaIssues = []

  # ============================================================================
  # STEP 8: Validate Helpers are Registered (Action)
  # ============================================================================
  - id: validate-helpers
    name: Validate Helper Registration
    type: action
    instruction: |
      Verify all required helpers are registered in the system.

      1. **Get registered helpers:**
         - Call: GET /api/helpers
         - Response: {helpers: [{name, description, example}]}
         - Extract helper names into registeredHelpers array

      2. **Compare required vs registered:**
         - For each helper in requiredHelpers:
           - Check if helper name exists in registeredHelpers
           - If not found: Add to missingHelpers array

      3. **Generate helper status list:**
         - For each required helper:
           - If registered: "✓ {helperName} (registered)"
           - If missing: "✗ {helperName} (NOT REGISTERED)"

      4. **Generate suggestions:**
         - For missing helpers: "Register helper '{helperName}' in src/services/handlebars/helpers/"

      5. **Display results:**
         - "Helper validation:"
         - List all required helpers with status
         - If missing helpers: "✗ {count} helper(s) not registered"
         - If all registered: "✓ All helpers registered"

      6. **Store results:**
         - `helperIssues`: array of {helper, message, severity: "error", suggestion}
         - `registeredHelpers`: array of registered helper names

  # ============================================================================
  # STEP 8: Check POEM Best Practices (Action)
  # ============================================================================
  - id: check-best-practices
    name: Check Best Practices
    type: action
    instruction: |
      Apply POEM best practice rules and collect findings.

      **Rules to check:**

      1. **Rule: Template should have corresponding input schema**
         - Check: hasInputSchema is true
         - If false: Add warning "Template missing input schema file"
         - Suggestion: "Create schema file at {workspace}/schemas/{promptName}.json"
         - Severity: warning

      2. **Rule: Large templates should be split**
         - Check: templateLineCount > 500
         - If true: Add info "Template is large ({lineCount} lines), consider splitting"
         - Suggestion: "Break template into smaller reusable components"
         - Severity: info

      3. **Rule: Helper argument count validation**
         - For each helper used in template:
           - Check if helper usage matches expected arguments (best effort)
           - Example: {{truncate text}} expects 2 args, {{truncate text 50}}
           - If mismatch detected: Add info "Helper '{helper}' may have incorrect arguments"
         - Severity: info

      4. **Rule: Nested placeholder structure**
         - Check for deeply nested placeholders (> 3 levels: a.b.c.d)
         - If found: Add info "Deep nesting detected: '{placeholder}', consider flattening"
         - Severity: info

      5. **Display results:**
         - "Best practice checks:"
         - If no issues: "✓ All best practices followed"
         - If issues: List each finding with severity icon
           - warning: "⚠"
           - info: "ℹ"

      6. **Store results:**
         - `bestPracticeIssues`: array of {rule, message, severity: "warning"|"info", suggestion}

  # ============================================================================
  # STEP 9: Aggregate Validation Results (Action)
  # ============================================================================
  - id: aggregate-results
    name: Aggregate Validation Results
    type: action
    instruction: |
      Collect all validation issues and categorize by severity.

      1. **Collect all issues:**
         - Combine: syntaxErrors + inputSchemaIssues + helperIssues + bestPracticeIssues
         - Total issue count = sum of all arrays

      2. **Categorize by severity:**
         - errorIssues = filter issues where severity === "error"
         - warningIssues = filter issues where severity === "warning"
         - infoIssues = filter issues where severity === "info"

      3. **Calculate validation status:**
         - If errorIssues.length > 0: status = "FAIL"
         - If errorIssues.length === 0: status = "PASS"

      4. **Generate summary:**
         - errorCount = errorIssues.length
         - warningCount = warningIssues.length
         - infoCount = infoIssues.length

      5. **Prepare fix suggestions:**
         - Group suggestions by category:
           - Syntax fixes
           - Schema updates
           - Helper registrations
           - Best practice improvements

      6. **Store results:**
         - `validationResults`: {
             status: "PASS"|"FAIL",
             errorCount, warningCount, infoCount,
             errors: errorIssues,
             warnings: warningIssues,
             info: infoIssues,
             suggestions: grouped suggestions
           }

  # ============================================================================
  # STEP 10: Display Validation Report (Output)
  # ============================================================================
  - id: validation-report
    name: Display Validation Report
    type: output
    instruction: |
      Present comprehensive validation report to user.

      1. **Display header:**
         - "=" * 60
         - "VALIDATION REPORT"
         - "Prompt: {promptName}"
         - "Path: {promptPath}"
         - "=" * 60

      2. **Display status:**
         - If PASS: "✓ All validation checks passed"
         - If FAIL: "✗ Validation failed with {errorCount} error(s)"

      3. **Display summary:**
         - "Summary:"
         - "  Errors:   {errorCount}"
         - "  Warnings: {warningCount}"
         - "  Info:     {infoCount}"

      4. **Display errors (if any):**
         - "ERRORS ({errorCount}):"
         - For each error:
           - "  ✗ {message}"
           - "    Location: {location}" (if available)
           - "    Suggestion: {suggestion}"

      5. **Display warnings (if any):**
         - "WARNINGS ({warningCount}):"
         - For each warning:
           - "  ⚠ {message}"
           - "    Suggestion: {suggestion}"

      6. **Display info (if any):**
         - "INFO ({infoCount}):"
         - For each info:
           - "  ℹ {message}"
           - "    Suggestion: {suggestion}"

      7. **Display footer:**
         - "=" * 60
         - If PASS: "Prompt is ready for use"
         - If FAIL: "Please fix errors before using this prompt"

  # ============================================================================
  # STEP 11: Offer to Save Validation Report (Elicitation)
  # ============================================================================
  - id: save-report
    name: Save Validation Report
    type: elicit
    elicit: true
    prompt: |
      Save validation report to file? (yes/no)

      **Default filename:** {promptName}-validation-report.json
    validation:
      required: true
      pattern: "^(yes|no|y|n)$"
      patternDescription: "yes, no, y, or n"
    stores: saveReportChoice
    instruction: |
      Ask user if they want to save the validation report.

      1. **Parse user response:**
         - "yes", "y" → Save report
         - "no", "n" → Skip saving

      2. **If user says yes:**
         - Prompt for filename (default: {promptName}-validation-report.json)
         - Build full path:
           - Development: `dev-workspace/{filename}`
           - Production: `poem/{filename}`
         - Write validationResults as JSON to file
         - Display: "✓ Report saved to: {filepath}"

      3. **If user says no:**
         - Display: "Validation complete. Report not saved."

      4. **Store results:**
         - `reportSaved`: boolean
         - `reportPath`: file path (if saved)

  # ============================================================================
  # STEP 12: Workflow Complete (Output)
  # ============================================================================
  - id: complete
    name: Workflow Complete
    type: output
    instruction: |
      Summarize validation session and suggest next steps.

      1. **Display completion message:**
         - "Validation workflow complete for: {promptName}"

      2. **Display session summary:**
         - "Status: {validationStatus}"
         - "Issues found: {errorCount} errors, {warningCount} warnings, {infoCount} info"

      3. **Display artifacts:**
         - If report saved: "Report saved to: {reportPath}"

      4. **Suggest next steps:**
         - If FAIL: "Next steps: *refine {promptName} to fix errors"
         - If PASS with warnings: "Next steps: *test {promptName} or address warnings"
         - If PASS no warnings: "Next steps: *test {promptName} or deploy"

      5. **Display available commands:**
         - "*refine {promptName}" - Fix issues in template
         - "*test {promptName}" - Test with data
         - "*help" - Show all commands
