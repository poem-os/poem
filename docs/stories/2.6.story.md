# Story 2.6: Create Schema Extraction API Endpoint

## Status

Done

## Story

**As a** skill or agent,
**I want** an API endpoint to extract schemas from templates,
**so that** required data fields are automatically identified.

## Acceptance Criteria

1. `POST /api/schema/extract` accepts template path or content
2. Endpoint parses Handlebars placeholders and blocks
3. Returns JSON schema with field names and inferred types
4. Handles nested objects: `{{obj.field}}` → `{obj: {field: string}}`
5. Handles arrays: `{{#each items}}` → `{items: array}`
6. Identifies required helpers used in template
7. Schema follows simple JSON format (not full JSON Schema spec initially)

## Tasks / Subtasks

- [x] Task 1: Create Schema Extractor service (AC: 2, 3, 4, 5)
  - [x] Create `packages/poem-app/src/services/schema/extractor.ts`
  - [x] Implement `SchemaExtractor` class with `extract(template: string)` method
  - [x] Parse simple placeholders: `{{fieldName}}` → `{fieldName: "string"}`
  - [x] Parse nested placeholders: `{{user.email}}` → `{user: {email: "string"}}`
  - [x] Parse `#each` blocks: `{{#each items}}` → `{items: "array"}`
  - [x] Parse `#if` blocks: `{{#if active}}` → `{active: "boolean"}`
  - [x] Handle array index access: `{{items.[0]}}` → `{items: "array"}`

- [x] Task 2: Implement helper detection (AC: 6)
  - [x] Extract helper calls from template (e.g., `{{truncate title 50}}`)
  - [x] Return list of required helpers in response
  - [x] Use `HandlebarsService.getHelpers()` to check for registered helpers
  - [x] Flag unregistered helpers in response

- [x] Task 3: Create API endpoint file structure (AC: 1)
  - [x] Create `packages/poem-app/src/pages/api/schema/extract.ts`
  - [x] Create directory `packages/poem-app/src/pages/api/schema/` if needed
  - [x] Export POST handler following Astro API conventions

- [x] Task 4: Define request/response types (AC: 1, 3, 7)
  - [x] Create `ExtractRequest` interface with `template`, `isRawTemplate` fields
  - [x] Create `ExtractResponse` interface with `schema`, `requiredHelpers`, `templatePath` fields
  - [x] Add input validation using Zod schema
  - [x] Schema format: `{fields: [{name, type, required, properties?, items?}]}`

- [x] Task 5: Implement template loading (AC: 1)
  - [x] If `isRawTemplate: true`, use template string directly
  - [x] If `isRawTemplate: false`, reuse `resolveTemplatePath()` from `render.ts` (or extract to shared utility)
  - [x] Read template file from filesystem
  - [x] Handle file not found with 404 response

- [x] Task 6: Implement endpoint logic (AC: 1, 2, 3, 6, 7)
  - [x] Import `SchemaExtractor` from schema service
  - [x] Call `extractor.extract(templateContent)`
  - [x] Return extracted schema, helpers, and template path
  - [x] Catch parsing errors and return 400 with helpful message

- [x] Task 7: Implement error handling (AC: 1)
  - [x] Return 400 for invalid JSON body
  - [x] Return 400 for missing required `template` field
  - [x] Return 400 for template syntax errors with line/column info
  - [x] Return 404 for template file not found
  - [x] Use consistent error response format: `{ success: false, error, details }`

- [x] Task 8: Write unit tests for SchemaExtractor service
  - [x] Create `packages/poem-app/tests/services/schema/extractor.test.ts`
  - [x] Test simple placeholder extraction
  - [x] Test nested object extraction (`{{user.name}}`)
  - [x] Test array extraction (`{{#each items}}`)
  - [x] Test conditional extraction (`{{#if active}}`)
  - [x] Test helper detection (`{{truncate title 50}}`)
  - [x] Test combined patterns in complex templates

- [x] Task 9: Write integration tests for API endpoint (AC: 1-7)
  - [x] Create `packages/poem-app/tests/api/schema-extract.test.ts`
  - [x] Test successful extraction with raw template
  - [x] Test successful extraction with file path
  - [x] Test 404 for missing template file
  - [x] Test 400 for invalid template syntax
  - [x] Test nested object schema output
  - [x] Test array schema output
  - [x] Test required helpers in response

## Dev Notes

### Previous Story Insights

[Source: Story 2.5 Completion Notes]

Story 2.5 established the template loading and API patterns:
- Template path resolution uses `resolveTemplatePath()` which looks in `/prompts/` at monorepo root
- `globalThis` singleton pattern for services that need cross-context sharing
- Zod validation at API boundary using schema pattern
- `renderWithWarnings()` already extracts placeholders - can reuse/extend this logic
- Test template exists at `/prompts/test/hello.hbs`

### File Locations

[Source: architecture/unified-project-structure.md]

```
packages/poem-app/
├── src/pages/api/
│   ├── health.ts              ← Existing health endpoint
│   ├── prompt/
│   │   └── render.ts          ← Story 2.5 reference for patterns
│   └── schema/
│       └── extract.ts         ← CREATE: Schema extraction endpoint
│
├── src/services/
│   ├── handlebars/
│   │   └── index.ts           ← HandlebarsService (has extractPlaceholders private method)
│   └── schema/
│       └── extractor.ts       ← CREATE: Schema extraction service
│
└── tests/
    ├── services/schema/
    │   └── extractor.test.ts  ← CREATE: Unit tests
    └── api/
        └── schema-extract.test.ts ← CREATE: Integration tests
```

### API Specification

[Source: architecture/api-specification.md]

```yaml
POST /api/schema/extract
Request:
  template: string      # Path relative to /prompts/ OR raw Handlebars content
  isRawTemplate?: bool  # If true, template is raw content (default: false)

Response (200):
  schema: object        # Extracted schema with fields
  requiredHelpers: string[]  # Helper names used in template
  templatePath?: string # Resolved template path (if file-based)

Response (400): Invalid request, syntax error
Response (404): Template file not found
```

### Data Models

[Source: architecture/data-models.md]

```typescript
// Schema field interface for extraction
interface SchemaField {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'array' | 'object';
  required: boolean;
  description?: string;
  items?: SchemaField;       // For arrays, the item type
  properties?: SchemaField[];  // For objects, nested fields
}

// PlaceholderInfo from existing service
interface PlaceholderInfo {
  path: string;              // e.g., "user.name"
  inferredType: 'string' | 'number' | 'boolean' | 'array' | 'object';
  isArrayItem: boolean;      // Inside #each block
  isConditional: boolean;    // Inside #if block
}
```

### Extraction Patterns

[Source: docs/prd/epic-details.md - Story 4.2]

The schema extractor should handle these 7 patterns from the YouTube workflow:

| Pattern | Example | Schema Output |
|---------|---------|---------------|
| Simple placeholder | `{{fieldName}}` | `{fieldName: "string"}` |
| Nested object | `{{object.field}}` | `{object: {field: "string"}}` |
| Array access | `{{items.[0]}}` | `{items: "array"}` |
| Each block | `{{#each items}}` | `{items: "array"}` |
| If block | `{{#if condition}}` | `{condition: "boolean"}` |
| Helper call | `{{truncate title 49}}` | identifies `truncate` helper, extracts `title` as field |
| Helper with comparison | `{{#if (gt length 20)}}` | identifies `gt` helper, extracts `length` as field |

### TypeScript Types

[Source: architecture/data-models.md, architecture/coding-standards.md]

```typescript
// Request interface
interface ExtractRequest {
  template: string;
  isRawTemplate?: boolean;
}

// Response interface
interface ExtractResponse {
  schema: {
    fields: SchemaField[];
  };
  requiredHelpers: string[];
  templatePath?: string;
}

// Error response format (consistent across all APIs)
interface ErrorResponse {
  success: false;
  error: string;
  details?: {
    path?: string;
    line?: number;
    column?: number;
  };
}
```

### Coding Standards

[Source: architecture/coding-standards.md]

**Critical Rules:**
- Validate input at API boundary using Zod
- Return consistent error format: `{ success: false, error, details }`
- All errors must include context (file path, line number for parse errors)
- Graceful degradation: unknown patterns should still extract what's possible

**API Endpoint Pattern:**
```typescript
import type { APIContext } from 'astro';

export async function POST({ request }: APIContext) {
  try {
    const body = await request.json();
    // Validate with Zod...
    // Process...
    return new Response(JSON.stringify({ success: true, ...data }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      details: { /* context */ }
    }), { status: 400, headers: { 'Content-Type': 'application/json' } });
  }
}
```

### Handlebars Service API

[Source: packages/poem-app/src/services/handlebars/index.ts]

The existing `HandlebarsService` has a private `extractPlaceholders()` method:
```typescript
// Current implementation (private) - extracts placeholder names only
private extractPlaceholders(template: string): string[]

// Available public methods
service.getHelpers(): HelperInfo[]  // Get registered helpers
service.hasHelper(name: string): boolean  // Check if helper exists
```

Consider either:
1. Making `extractPlaceholders` public and extending it for type inference
2. Creating a new `SchemaExtractor` service that uses Handlebars AST parsing

**Recommended approach:** Create a new `SchemaExtractor` service using regex-based parsing initially (simpler), with option to use Handlebars AST in future for complex cases.

### Testing Standards

[Source: architecture/testing-strategy.md]

**Test file locations:**
- Unit: `packages/poem-app/tests/services/schema/extractor.test.ts`
- Integration: `packages/poem-app/tests/api/schema-extract.test.ts`

**Coverage target:** 85% for Schema Extractor (complex parsing logic)

**Test pattern for services:**
```typescript
import { describe, it, expect } from 'vitest';
import { SchemaExtractor } from '../../../src/services/schema/extractor';

describe('SchemaExtractor', () => {
  const extractor = new SchemaExtractor();

  describe('extract', () => {
    it('should extract simple placeholders', () => {
      const result = extractor.extract('Hello {{name}}');
      expect(result.fields).toContainEqual({
        name: 'name',
        type: 'string',
        required: true
      });
    });

    it('should extract nested objects', () => {
      const result = extractor.extract('{{user.email}}');
      expect(result.fields).toContainEqual({
        name: 'user',
        type: 'object',
        required: true,
        properties: [{
          name: 'email',
          type: 'string',
          required: true
        }]
      });
    });
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-30 | 0.1 | Initial story draft | Bob (SM Agent) |
| 2025-12-30 | 0.2 | PO validation: GO decision, added resolveTemplatePath reuse guidance | Sarah (PO Agent) |
| 2025-12-30 | 0.3 | Status changed to Ready | User |
| 2025-12-30 | 1.0 | Implementation complete, all tests pass, status Review | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

- Fixed `{{this}}` and `@index`/`@first` extraction bug by adding `isFieldReference()` check before `addFieldPath()` call

### Completion Notes List

- Created SchemaExtractor service with regex-based parsing (as recommended in story notes)
- Implemented all 7 extraction patterns from the PRD
- Added `unregisteredHelpers` field to response (checks against HandlebarsService)
- Reused `resolveTemplatePath()` pattern from render.ts (as specified in Task 5)
- All 230 tests pass (26 unit + 26 integration for this story, plus existing regression suite)

### File List

**Created:**
- `packages/poem-app/src/services/schema/extractor.ts` - SchemaExtractor service
- `packages/poem-app/src/pages/api/schema/extract.ts` - API endpoint
- `packages/poem-app/tests/services/schema/extractor.test.ts` - Unit tests (26 tests)
- `packages/poem-app/tests/api/schema-extract.test.ts` - Integration tests (26 tests)

---

## QA Results

### Review Date: 2025-12-30

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall**: Excellent implementation. Clean, well-structured code following established patterns from Story 2.5. The SchemaExtractor service demonstrates good separation of concerns with clear private methods for each extraction pattern.

**Strengths**:
- Proper TypeScript typing throughout (SchemaField, ExtractionResult, ExtractRequest, ExtractResponse)
- Zod validation at API boundary as per coding standards
- Consistent error response format with context
- Good edge case handling (bug fix for `{{this}}` and `@` variables documented in Debug Log)
- Comprehensive test coverage (52 tests for this story)

**Architecture**:
- Regex-based parsing approach is appropriate for current needs (as recommended in story notes)
- Clear extensibility path to AST-based parsing if needed later
- Proper reuse of `resolveTemplatePath()` pattern

### Refactoring Performed

None required. Code quality meets standards.

### Compliance Check

- Coding Standards: ✓ Zod validation, error format, TypeScript types all correct
- Project Structure: ✓ Files in correct locations per unified-project-structure.md
- Testing Strategy: ✓ 26 unit + 26 integration tests, exceeds 85% coverage target
- All ACs Met: ✓ All 7 acceptance criteria verified

### Improvements Checklist

- [x] All extraction patterns implemented correctly
- [x] Helper detection with registered/unregistered distinction
- [x] Bug fix for `{{this}}` and `@` variables documented in KDD
- [ ] Consider extracting `resolveTemplatePath()` to shared utility (future story)
- [ ] Consider adding `description` field inference from comments (future enhancement)

### Security Review

No concerns. API operates on templates only, no user data exposure. Workspace isolation maintained.

### Performance Considerations

No concerns. Regex-based parsing is efficient for typical template sizes. Consider AST parsing only if performance issues arise with very large templates.

### Files Modified During Review

None.

### Gate Status

Gate: PASS → docs/qa/gates/2.6-schema-extraction-api.yml

### Recommended Status

✓ Ready for Done

**Note**: The `health.test.ts` failure in test run is a known flaky test (server startup timeout) unrelated to this story. All 52 Story 2.6 tests pass. This flaky test is tracked in the maintenance backlog.
