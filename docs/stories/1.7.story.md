# Story 1.7: Startup Script and Port Configuration

## Status

Draft

## Story

**As a** user,
**I want** to start POEM from my project root and configure the server port,
**so that** I can run POEM without navigating into .poem-app/ and manage multiple POEM instances on different ports.

## Background

This story continues Epic 1: Foundation & Monorepo Setup. Stories 1.1-1.5 established the monorepo structure, created both packages, implemented the NPX installer, and integrated Claude Code slash commands. Story 1.6 enabled NPM publishing, making POEM globally installable via `npx poem-os install`.

Currently, users must manually navigate to `.poem-app/` and run `npm run dev` to start the POEM server. This is cumbersome and doesn't support port configuration or multi-instance scenarios. This story adds CLI commands for starting the server and managing configuration, completing the foundation for a polished user experience.

**References**:
- Epic 1 Goal: `docs/prd/epic-details.md` (lines 3-5)
- Previous Story 1.6: NPM Package Publishing (installer verified, package.json configured)
- Existing Code: `bin/install.js` (installer pattern), `packages/poem-app/astro.config.mjs` (PORT env var support)

## Acceptance Criteria

1. `npx poem-os start` command launches POEM server from project root
2. Startup script validates `.poem-app/` exists and shows helpful error if not
3. During installation, users prompted for port number (default: 4321)
4. Port configuration written to `.poem-app/.env`
5. Users can override port temporarily: `npx poem-os start --port=XXXX`
6. Users can reconfigure port permanently: `npx poem-os config --port XXXX`
7. Users can view current config: `npx poem-os config --list`
8. Port validation rejects invalid values (< 1024 or > 65535)
9. Startup script is cross-platform compatible (Windows/macOS/Linux)
10. Documentation updated (README.md, PUBLISHING.md)

## Tasks / Subtasks

- [ ] Task 1: Refactor bin/install.js to Support Multiple Commands (AC: 1, 5, 6, 7)
  - [ ] Extract command router to dispatch to install/start/config subcommands
  - [ ] Keep existing install functionality intact
  - [ ] Add command validation (reject unknown commands)
  - [ ] Update help text to show all available commands
  - [ ] Write unit tests for command routing

- [ ] Task 2: Add Port Configuration to Installation Flow (AC: 3, 4, 8)
  - [ ] Add interactive prompt for port number during `npx poem-os install`
  - [ ] Default to 4321 if user skips
  - [ ] Validate port number (1024-65535)
  - [ ] Write PORT=XXXX to `.poem-app/.env` after installation
  - [ ] Create `.poem-app/.env` if it doesn't exist, append if it does
  - [ ] Write unit tests for port validation and .env writing

- [ ] Task 3: Implement `npx poem-os start` Command (AC: 1, 2, 5, 9)
  - [ ] Create start command handler in bin/ directory
  - [ ] Validate `.poem-app/` directory exists (show helpful error if not)
  - [ ] Check for PORT in `.poem-app/.env` (use 4321 if missing)
  - [ ] Support `--port=XXXX` flag to override temporarily
  - [ ] Use `child_process.spawn` to launch Astro server with PORT env var
  - [ ] Pass through stdout/stderr for server logs
  - [ ] Handle Ctrl+C gracefully (cleanup child process)
  - [ ] Test on all platforms (Windows/macOS/Linux via CI matrix)
  - [ ] Write unit tests for start command logic

- [ ] Task 4: Implement `npx poem-os config` Command (AC: 6, 7, 8)
  - [ ] Create config command handler in bin/ directory
  - [ ] Support `--port XXXX` flag to update PORT in `.poem-app/.env`
  - [ ] Validate port number (1024-65535)
  - [ ] Read existing `.poem-app/.env` and update PORT line (preserve other vars)
  - [ ] Support `--list` flag to display current configuration
  - [ ] Parse and display PORT, POEM_DEV, and other vars from `.env`
  - [ ] Show helpful error if `.poem-app/` doesn't exist
  - [ ] Write unit tests for config reading/writing

- [ ] Task 5: Create Shared Utilities (AC: 2, 8, 9)
  - [ ] Create `bin/utils.js` with shared functions
  - [ ] Add `validatePoemInstalled()` - checks `.poem-app/` exists
  - [ ] Add `validatePort(port)` - validates port number range
  - [ ] Add `readEnvFile(path)` - parses .env file to key-value object
  - [ ] Add `writeEnvFile(path, config)` - writes config object to .env format
  - [ ] Use Node.js `path`, `fs/promises`, `os` for cross-platform compatibility
  - [ ] Write comprehensive unit tests for all utilities

- [ ] Task 6: Update Package.json Bin Configuration (AC: 1, 6, 7)
  - [ ] Verify `"bin": { "poem-os": "./bin/install.js" }` supports multi-command routing
  - [ ] No changes needed (router dispatches internally)
  - [ ] Confirm `npx poem-os <command>` pattern works

- [ ] Task 7: Cross-Platform Testing (AC: 9)
  - [ ] Test on macOS (local development)
  - [ ] Test on Linux (via Docker or CI)
  - [ ] Test on Windows (via CI or local VM)
  - [ ] Verify path handling works on all platforms
  - [ ] Verify child process spawning works on all platforms
  - [ ] Verify .env file reading/writing works on all platforms

- [ ] Task 8: Update Documentation (AC: 10)
  - [ ] Update README.md Usage section with `start` and `config` commands
  - [ ] Add examples: `npx poem-os start`, `npx poem-os start --port=3000`
  - [ ] Add examples: `npx poem-os config --port 8080`, `npx poem-os config --list`
  - [ ] Update PUBLISHING.md with installation flow changes (port prompt)
  - [ ] Document port validation rules (1024-65535)
  - [ ] Add troubleshooting section for common issues

- [ ] Task 9: Write Comprehensive Unit Tests (AC: All)
  - [ ] Test command routing (valid commands, unknown commands)
  - [ ] Test port validation (valid, too low, too high, non-numeric)
  - [ ] Test .env file operations (read, write, update, missing file)
  - [ ] Test validatePoemInstalled (directory exists, directory missing)
  - [ ] Test start command logic (with/without --port flag)
  - [ ] Test config command logic (--port, --list, invalid args)
  - [ ] Target 80% coverage for bin/ scripts per testing strategy
  - [ ] Use Vitest for consistency with poem-app tests

- [ ] Task 10: Manual Testing Scenarios (AC: All)
  - [ ] Fresh installation with port prompt
  - [ ] Start command from project root
  - [ ] Start command with --port override
  - [ ] Config command to change port permanently
  - [ ] Config --list to view current config
  - [ ] Error handling: start without installation
  - [ ] Error handling: invalid port numbers
  - [ ] Multi-instance test: run two POEM servers on different ports

## Dev Notes

### Previous Story Insights

[Source: Story 1.6 Dev Agent Record]

**Key Learnings from Story 1.6**:
- Successfully updated package.json for NPM publishing (removed private field, added bin/files/repository)
- All local installation tests passed (full install, --core, --app flags)
- Installer compatibility verified (shebang, permissions, Node.js version check)
- Created comprehensive PUBLISHING.md with manual publishing workflow
- Updated README.md with installation instructions

**Reusable Patterns**:
- `bin/install.js` provides command-line argument parsing pattern
- Node.js version check pattern (`checkNodeVersion()`)
- Interactive prompts using `readline` module
- File copy operations using `fs/promises`
- Cross-platform path handling using `path` module

### Architecture Context: Tech Stack

[Source: docs/architecture/tech-stack.md]

**Runtime and Distribution**:
- **Node.js**: 22.x LTS (required minimum, checked in installer)
- **TypeScript**: 5.9.x (type-safe server code)
- **npm**: 10.x (package manager)
- **npx**: Distribution method (`npx poem-os <command>`)
- **Astro**: 5.x (server framework, already configured to read PORT from env)

**Key Technology Decisions**:
- File-based configuration (.env files, no database)
- NPX for zero-install command execution
- Cross-platform compatibility required (macOS, Linux, Windows)

### Architecture Context: Project Structure

[Source: docs/architecture/unified-project-structure.md]

**Relevant File Locations**:
- **Installer Script**: `bin/install.js` (lines 113-114)
  - Entry point for `npx poem-os <command>`
  - Already implements install command
  - Needs refactoring to support multiple commands (install, start, config)

- **Installed Runtime**: `packages/poem-app/` (lines 54-111)
  - After installation, becomes `.poem-app/` in user projects
  - Contains `astro.config.mjs` which reads PORT from `process.env`
  - Contains `.env` file for configuration

- **Astro Configuration**: `packages/poem-app/astro.config.mjs`
  - Already configured: `port: parseInt(process.env.PORT || "4321", 10)`
  - No changes needed to Astro config
  - Start command just needs to set PORT env var before spawning

- **Environment File**: `packages/poem-app/.env`
  - Currently contains: `POEM_DEV=true`
  - Format: Simple `KEY=VALUE` pairs, one per line
  - Need to add PORT configuration during installation

**Root Package.json**:
- Location: `package.json` (line 131)
- Bin configuration: `"bin": { "poem-os": "./bin/install.js" }`
- No changes needed (router dispatches commands internally)

### Architecture Context: Coding Standards

[Source: docs/architecture/coding-standards.md]

**Critical Rules for This Story**:

1. **File-Based Everything**: Configuration stored in `.env` files (no database)

2. **Workspace Isolation**: Only access files within user's project root and `.poem-app/`

3. **Error Context**: All CLI errors must include: error type, message, helpful suggestions

4. **Graceful Degradation**: Missing config uses sensible defaults (PORT=4321)

5. **Cross-Platform Compatibility**: Use Node.js built-in modules for path handling

**Naming Conventions**:
- CLI commands: kebab-case (`start`, `config`)
- Environment variables: SCREAMING_SNAKE_CASE (`PORT`, `POEM_DEV`)
- JavaScript files: camelCase (`utils.js`)
- Config files: kebab-case.yaml/json

**TypeScript Standards** (if adding types):
```typescript
// ✅ DO: Use explicit types for command handlers
interface CommandHandler {
  (args: string[], flags: Record<string, any>): Promise<void>;
}

// ✅ DO: Use Result types for operations that can fail
type Result<T> = { success: true; data: T } | { success: false; error: string };
```

**CLI Error Handling Pattern**:
```javascript
// ✅ DO: Provide helpful error messages with suggestions
if (!fs.existsSync('.poem-app')) {
  console.error('\n❌ POEM is not installed in this directory.');
  console.error('   Run: npx poem-os install\n');
  process.exit(1);
}

// ✅ DO: Validate user input with clear feedback
function validatePort(port) {
  const num = parseInt(port, 10);
  if (isNaN(num) || num < 1024 || num > 65535) {
    throw new Error(`Invalid port: ${port}. Port must be between 1024 and 65535.`);
  }
  return num;
}
```

### Architecture Context: Testing Strategy

[Source: docs/architecture/testing-strategy.md]

**Testing Approach for CLI Scripts**:
- **Unit Tests**: Vitest for utility functions (port validation, .env parsing)
- **Manual Testing**: Test actual CLI commands on multiple platforms
- **Integration Tests**: Test command routing and file operations
- **Cross-Platform Tests**: CI matrix for macOS/Linux/Windows

**Test Organization**:
```
tests/
├── bin/
│   ├── command-router.test.ts      # Test command dispatching
│   ├── utils.test.ts               # Test shared utilities
│   ├── start-command.test.ts       # Test start command logic
│   └── config-command.test.ts      # Test config command logic
└── fixtures/
    └── mock-env-files/             # Sample .env files for testing
```

**Coverage Target**: 80% for bin/ scripts

**Manual Test Scenarios** (from AC):
1. Fresh installation with port prompt
2. Start from project root (default port and custom port)
3. Config command (set port, list config)
4. Error scenarios (missing installation, invalid ports)
5. Multi-instance test (two servers on different ports)

### Implementation Notes

**Task 1: Command Router Pattern**

Current `bin/install.js` structure:
```javascript
// Existing pattern:
const { command, flags } = parseArgs();
if (command === 'install') { ... }

// New multi-command pattern:
const { command, flags } = parseArgs();
switch (command) {
  case 'install': await handleInstall(flags); break;
  case 'start': await handleStart(flags); break;
  case 'config': await handleConfig(flags); break;
  default: showHelp(); process.exit(1);
}
```

**Task 2: Port Prompt During Installation**

Add to installation flow after directory prompts:
```javascript
async function promptForPort() {
  const answer = await question('Server port [4321]: ');
  const port = answer.trim() || '4321';
  return validatePort(port);
}

// After copying files:
const port = await promptForPort();
await writeEnvFile('.poem-app/.env', { PORT: port, POEM_DEV: 'false' });
```

**Task 3: Start Command Implementation**

```javascript
import { spawn } from 'child_process';
import * as path from 'path';

async function handleStart(flags) {
  validatePoemInstalled(); // Throws if .poem-app/ missing

  // Load PORT from .env or use default
  const envConfig = await readEnvFile('.poem-app/.env');
  const port = flags.port || envConfig.PORT || '4321';
  validatePort(port);

  // Spawn Astro dev server with PORT env var
  const appDir = path.resolve('.poem-app');
  const child = spawn('npm', ['run', 'dev'], {
    cwd: appDir,
    env: { ...process.env, PORT: port },
    stdio: 'inherit', // Pass through stdout/stderr
  });

  // Handle Ctrl+C
  process.on('SIGINT', () => {
    child.kill('SIGINT');
    process.exit(0);
  });
}
```

**Task 4: Config Command Implementation**

```javascript
async function handleConfig(flags) {
  validatePoemInstalled();

  if (flags.list) {
    // Display current config
    const config = await readEnvFile('.poem-app/.env');
    console.log('\nCurrent POEM Configuration:');
    console.log(`  PORT: ${config.PORT || '4321 (default)'}`);
    console.log(`  POEM_DEV: ${config.POEM_DEV || 'false'}\n`);
    return;
  }

  if (flags.port) {
    // Update PORT in .env
    const port = validatePort(flags.port);
    const config = await readEnvFile('.poem-app/.env');
    config.PORT = port;
    await writeEnvFile('.poem-app/.env', config);
    console.log(`✅ Port updated to ${port}`);
    return;
  }

  // No valid flags
  console.error('Usage: npx poem-os config --list | --port XXXX');
  process.exit(1);
}
```

**Task 5: Shared Utilities**

```javascript
// bin/utils.js
import * as fs from 'fs/promises';
import * as path from 'path';

export function validatePoemInstalled() {
  if (!fs.existsSync('.poem-app')) {
    console.error('\n❌ POEM is not installed in this directory.');
    console.error('   Run: npx poem-os install\n');
    process.exit(1);
  }
}

export function validatePort(port) {
  const num = parseInt(port, 10);
  if (isNaN(num) || num < 1024 || num > 65535) {
    throw new Error(`Invalid port: ${port}. Must be 1024-65535.`);
  }
  return num;
}

export async function readEnvFile(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const config = {};
    for (const line of content.split('\n')) {
      const [key, ...values] = line.split('=');
      if (key && values.length > 0) {
        config[key.trim()] = values.join('=').trim();
      }
    }
    return config;
  } catch (error) {
    if (error.code === 'ENOENT') return {};
    throw error;
  }
}

export async function writeEnvFile(filePath, config) {
  const lines = Object.entries(config).map(([key, value]) => `${key}=${value}`);
  await fs.writeFile(filePath, lines.join('\n') + '\n', 'utf-8');
}
```

**Cross-Platform Considerations**:
- Use `path.resolve()` for absolute paths
- Use `path.join()` for path concatenation
- Use `process.platform` if platform-specific logic needed
- Test `spawn()` command on Windows (may need shell wrappers)

### File Locations Summary

**Implementation Files**:
- `bin/install.js` (existing, modify to add command router)
- `bin/start.js` (new, start command handler)
- `bin/config.js` (new, config command handler)
- `bin/utils.js` (new, shared utilities)

**Configuration Files**:
- `packages/poem-app/.env` (existing, add PORT during installation)
- `packages/poem-app/astro.config.mjs` (no changes, already reads PORT)

**Test Files**:
- `tests/bin/command-router.test.ts` (new)
- `tests/bin/utils.test.ts` (new)
- `tests/bin/start-command.test.ts` (new)
- `tests/bin/config-command.test.ts` (new)
- `tests/fixtures/mock-env-files/` (new test fixtures)

**Documentation Files**:
- `README.md` (modify, add start/config commands to Usage)
- `PUBLISHING.md` (modify, document port configuration prompt)

## Testing

[Source: docs/architecture/testing-strategy.md]

**Test File Locations**:
- Unit tests: `tests/bin/`
- Test fixtures: `tests/fixtures/mock-env-files/`
- Manual tests: Run actual CLI commands on dev machine + CI

**Test Standards**:
- Use Vitest for unit tests (consistency with poem-app tests)
- Target 80% coverage for bin/ scripts
- Test cross-platform behavior via CI matrix (macOS, Linux, Windows)
- Manual testing required for actual command execution

**Testing Frameworks**:
- Vitest for unit tests
- Manual testing via terminal for CLI commands
- CI/CD matrix for cross-platform validation

**Test Execution**:
```bash
# Run all tests
npm test

# Run bin tests only
npm test tests/bin

# Run with coverage
npm test -- --coverage

# Manual testing
npx poem-os install
npx poem-os start
npx poem-os start --port=3000
npx poem-os config --list
npx poem-os config --port 8080
```

**Key Test Scenarios**:
1. Command routing (install, start, config, unknown)
2. Port validation (valid: 4321, 8080; invalid: 80, 70000, abc)
3. .env file operations (read existing, write new, update existing)
4. validatePoemInstalled (directory exists, directory missing)
5. Start command (default port, custom port via flag, missing installation)
6. Config command (--list, --port, invalid flags)
7. Cross-platform compatibility (paths, spawning, .env line endings)
8. Multi-instance scenario (two servers on different ports)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-14 | 1.0 | Initial story draft created | Bob (SM) |
