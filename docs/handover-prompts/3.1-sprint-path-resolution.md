# Handover Prompt: Path Resolution Architecture Decision

## Context

This handover is for a new Claude Code conversation with the Scrum Master (Bob) to address a critical architectural gap discovered after completing Story 3.1.

**Copy everything below the line into a new conversation:**

---

## Handover: POEM Path Resolution Architecture

### Background

We just completed Story 3.1 (Create Prompt Engineer Agent Definition) and discovered a critical gap: **POEM has no clear mechanism for resolving file paths in both development and production modes.**

When testing the new agent via `/poem/agents/prompt-engineer`, it failed to load:
- `.poem-core/core-config.yaml` (file doesn't exist at this path)
- `.poem-core/data/poem-principles.md` (file doesn't exist at this path)

The agent gracefully degraded, but this reveals a fundamental problem that will block Stories 3.2-3.6.

### The Problem

**Source of Truth Location**: `packages/poem-core/` (where we develop)

**Slash Command Expects**: `.poem-core/{type}/{name}` (the installed location)

**API Endpoints Hardcode**: Monorepo navigation via `../..` from `packages/poem-app/`

```typescript
// Current hardcoded path resolution in render.ts:58-64
function resolveTemplatePath(templatePath: string): string {
  const monorepoRoot = path.resolve(process.cwd(), '..', '..');
  const poemPromptsPath = path.join(monorepoRoot, 'prompts', templatePath);
  return poemPromptsPath;
}
```

**Config File Exists But Unused**: `packages/poem-core/core-config.yaml` defines `workspace.prompts: poem/prompts` but nothing reads it.

### Two Usage Modes

| Mode | Root Directory | Framework Location | User Workspace |
|------|----------------|-------------------|----------------|
| **Development** | `~/dev/ad/poem-os/poem` | `packages/poem-core/` | `prompts/`, `schemas/` at root |
| **Production** | User's project root | `.poem-core/` | `poem/prompts/`, `poem/schemas/` |

### BMAD's Solution (Research Summary)

BMAD v4 solves this elegantly:

1. **Source of Truth**: Official repo (`v4/` folder)
2. **Installation Target**: `.bmad-core/` in user projects
3. **Path Resolution**: Config-driven via `core-config.yaml`
4. **Slash Commands**: Generated at install time, self-contained with `IDE-FILE-RESOLUTION` rules
5. **Development Mode**: Developers work on source, run installer to test
6. **Key Pattern**: No hardcoded paths - everything reads from config

### Proposed Solution for POEM

Following BMAD's pattern:

1. **Configuration-Driven Resolution**
   - All paths read from `core-config.yaml`
   - API endpoints load config on startup
   - Agents reference config for workspace paths

2. **Mode Detection**
   - Environment variable: `POEM_MODE=development|production`
   - Or: Detect presence of `.poem-core/` vs `packages/poem-core/`
   - Or: Config file location determines mode

3. **Development Convenience**
   - Option A: Symlink `.poem-core/` â†’ `packages/poem-core/` during development
   - Option B: Environment-based path prefix
   - Option C: Dual config loading (check both locations)

4. **Single Source of Truth**
   - Source files always in `packages/poem-core/`
   - Installer copies to `.poem-core/` at install time
   - Development uses symlink or environment override

### Impact on Epic 3

**Story 3.1** (Complete): Agent definition works but gracefully degrades when files not found

**Stories 3.2-3.6** (Upcoming): ALL blocked because workflows will:
- Create files at `/poem/prompts/` - path resolution required
- Call API endpoints - hardcoded paths will fail in production
- Reference skills and data files - need resolution mechanism

### Files Needing Updates

1. **API Endpoints** (path resolution):
   - `packages/poem-app/src/pages/api/prompt/render.ts`
   - `packages/poem-app/src/pages/api/schema/extract.ts`

2. **Configuration Loading** (new):
   - Create config loading service
   - Load on server startup
   - Expose to API handlers

3. **Slash Command Wrapper**:
   - `.claude/commands/poem/agents/prompt-engineer.md` - verify `IDE-FILE-RESOLUTION` works

4. **Development Setup**:
   - Create symlink script or document manual setup
   - Or implement environment-based path detection

### Request to Scrum Master

Please help determine the best approach:

1. **Create a new story** (e.g., 3.0.5 or inject into Epic 2 backlog) to address path resolution before continuing with 3.2-3.6

2. **Decide on approach**:
   - Environment variable approach (simplest)
   - Symlink approach (BMAD-like)
   - Dual-location detection (most automatic)

3. **Scope the work**:
   - Minimum: Fix API path resolution to read config
   - Medium: Add development symlink + config loading
   - Full: Complete installer foundation for production mode

### Recommended Next Steps

1. Review this analysis with PO/Architect if needed
2. Create story for "Path Resolution Configuration"
3. Implement before Stories 3.2-3.6
4. Test both development and simulated production modes

### Reference Documents

- **BMAD Installation Pattern**: `/Users/davidcruwys/dev/ad/brains/bmad-method/v4` (especially `install.js` and `core-config.yaml`)
- **POEM Architecture**: `docs/architecture.md` (lines ~1687-1699 for workspace structure)
- **Current Config**: `packages/poem-core/core-config.yaml`
- **Current API**: `packages/poem-app/src/pages/api/prompt/render.ts:58-64`

### Questions for Decision

1. Should path resolution be a separate story (blocking 3.2) or woven into 3.2?
2. Which mode detection approach: environment variable, symlink, or auto-detection?
3. Should we implement full installer scaffolding now or defer to later epic?
4. Is `packages/poem-core/` the correct source of truth, or should we move to root `.poem-core/` even in development?

---

*Handover prepared: 2025-12-31*
*Context: Post Story 3.1 completion, pre Stories 3.2-3.6*
