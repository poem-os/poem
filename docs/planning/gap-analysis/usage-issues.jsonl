{"timestamp": "2026-01-15T14:30:00Z", "session": "vibedeck-usage-2026-01-15", "category": "missing-feature", "severity": "high", "observation": "Installation creates dev-workspace in wrong location (.poem-app/dev-workspace) and poem/ workspace doesn't follow multi-workflow folder structure pattern. Dev workspace should only exist during POEM development (in packages/poem-core/), not in production installs. Additionally, installed poem/ directory has flat structure (poem/prompts/, poem/schemas/, poem/config/) instead of multi-workflow pattern (poem/workflows/[workflow-name]/{config,prompts,schemas,workflow-data}/) that's used in dev-workspace.", "context": "After running 'poem-os install' in vibedeck project. Installer created .poem-app/dev-workspace/ (unexpected) and poem/ workspace with flat structure.", "expected": "1) No dev-workspace in production installs. 2) poem/workflows/[workflow-name]/ structure matching dev-workspace pattern. 3) Possibly a starter workflow created during install (Epic 1.6/1.7).", "actual": "1) .poem-app/dev-workspace/ created in production install. 2) poem/ has flat structure: poem/prompts/, poem/schemas/, poem/config/, poem/workflow-data/, poem/mappings/, poem/mock-data/, poem/templates/, poem/archive/. 3) No workflow-specific folders.", "impact": "Multi-workflow projects can't organize prompts/schemas/config by workflow. No clear path to add new workflows with proper folder structure. Confusion about whether dev-workspace should exist in production.", "tags": ["installation", "folder-structure", "multi-workflow", "epic-1", "epic-5", "epic-6"], "references": {"files": [".poem-app/dev-workspace/", "poem/", "packages/poem-core/dev-workspace/workflows/nano/", "packages/poem-core/dev-workspace/workflows/banana/", "packages/poem-core/dev-workspace/workflows/youtube-launch-optimizer/"], "commands": ["poem-os install"], "docs": ["docs/stories/story-1.6.md", "docs/stories/story-1.7.md", "docs/stories/story-3.7.md", "docs/prd.md#epic-4", "docs/prd.md#epic-5", "docs/prd.md#epic-6"]}, "additional_notes": "Uncertainty about which epic should own 'add workflow' capability: Epic 1 (installation), Epic 5 (workflow management), or Epic 6 (agents). This might need a dedicated command or agent feature. Pattern shows each workflow needs: config/, prompts/, schemas/, workflow-data/ subdirectories.", "suggestedEpic": "Epic 0", "suggestedStory": null, "epicRationale": "Infrastructure issue discovered post-Epic-1-completion affecting workspace organization and multi-workflow support", "resolution": {"status": "fixed", "fixedIn": "commit 5a3744a", "fixedDate": "2026-01-21T07:34:00Z", "fixDescription": "Added dev-workspace to EXCLUDE_PATTERNS in bin/install.js and removed empty packages/poem-app/dev-workspace/ directory from source. Now dev-workspace only exists at project root during POEM development.", "verifiedBy": "David Cruwys"}}
{"timestamp": "2026-01-15T14:45:00Z", "session": "vibedeck-usage-2026-01-15", "category": "usability", "severity": "medium", "observation": "Port configuration during installation uses wrong defaults and increment pattern. Installer defaults to port 4321 and suggests sequential increments (4322, 4323, etc.). Desired pattern: default 9500, increment by 10 (9510, 9520, 9530...). When installing second POEM instance, installer suggested 4322 instead of detecting it's a second install and suggesting 9510. Port selection should be intelligent about multi-instance scenarios.", "context": "Installation prompt 'What port should POEM run on? (default: 4321):' during vibedeck and supportsignal installs. User manually entered 9500 for supportsignal.", "expected": "1) Default port: 9500 (not 4321). 2) Suggested ports increment by 10: 9510, 9520, 9530, 9540, 9550. 3) For second install, detect existing instance and suggest next port in sequence (9510). 4) Installation prompt should mention recommended range.", "actual": "1) Default: 4321. 2) Suggestions shown: 4322, 4323, 5321, 8321. 3) No detection of existing POEM installations. 4) Increment pattern is +1, not +10.", "impact": "Users installing multiple POEM instances get wrong port suggestions and have to manually calculate port numbers. No guidance on port numbering strategy. Creates inconsistent port assignments across projects.", "tags": ["installation", "configuration", "port", "multi-instance", "epic-1"], "references": {"commands": ["poem-os install"], "docs": ["docs/stories/story-1.7.md"]}, "additional_notes": "User wants starting range around 9500 but open to research on best port range. Installer logic should be deterministic (not LLM-based). Consider: 1) Scanning for existing .poem-app/ installations to suggest next port. 2) Storing last-used port globally. 3) Validation that port is available. Port range 9500-9999 gives ~50 installations with +10 increment.", "suggestedEpic": "Epic 0", "suggestedStory": null, "epicRationale": "Usability improvement to installation discovered post-completion requiring configuration refinement", "resolution": {"status": "resolved", "fixedIn": "Story 1.7", "fixedDate": "2026-01-20T00:00:00Z", "fixDescription": "Port configuration already correct: default 9500, increments by +10 (9510, 9520, 9530...). Verified in bin/utils.js suggestAvailablePorts() function.", "verifiedBy": "David Cruwys"}}
{"timestamp": "2026-01-15T14:50:00Z", "session": "vibedeck-usage-2026-01-15", "category": "bug", "severity": "high", "observation": "Slash command uses role name instead of agent name. Installation instructions show '/poem/agents/prompt-engineer' but agent should be accessed by name: '/penny' or '/poem/agents/penny'. Prompt engineering is the umbrella role Penny performs (create agent, create prompt, refine prompt, create workflow, add to workflow, etc.), but activation is by agent name, not role. This was thought to be already fixed based on previous agent mapping work with Claude Code.", "context": "Post-installation output showing 'Slash Commands: /poem/agents/prompt-engineer - Activate Prompt Engineer agent'.", "expected": "Slash command shown as '/penny' or '/poem/agents/penny'. Instructions should reference agent by name (Penny), not by role (prompt-engineer).", "actual": "Installation output shows '/poem/agents/prompt-engineer'. Using role as command identifier instead of agent name.", "impact": "Confusing UX - users learn wrong command syntax. Inconsistent with agent naming convention. Makes it harder to remember which agent does what if referenced by role instead of persona name.", "tags": ["agents", "slash-commands", "installation", "naming", "claude-code-integration", "epic-6"], "references": {"commands": ["/poem/agents/prompt-engineer", "/penny", "/poem/agents/penny"], "files": [".claude/commands/poem/agents/penny.md"], "docs": ["docs/prd.md#epic-6"]}, "additional_notes": "Previous work established agent names (Penny) map to Claude Code slash commands. This regression suggests installer or command registration isn't using correct agent name mappings. All agents should follow this pattern: /[agent-name] as primary, /poem/agents/[agent-name] as alternative.", "suggestedEpic": "Epic 4", "suggestedStory": null, "epicRationale": "Workflow validation issue where slash command registration doesn't match agent naming schema validation"}
{"timestamp": "2026-01-15T15:00:00Z", "session": "vibedeck-usage-2026-01-15", "category": "missing-feature", "severity": "critical", "observation": "No extension mechanism for usage-specific agent customization. VibeDeck workflow research identified need to extend Penny with domain knowledge (model research, design concepts, manufacturing analysis) and new commands (*model-suggest, *model-compare, *dimension, *manufacturing-check), but this requires modifying POEM core files (.poem-core/poem-core-config.yaml) and core agent (Penny). This feels architecturally wrong - core agents shouldn't be modified for project-specific workflows. Need extension/plugin pattern where projects can add workflow-specific knowledge bases, commands, and agent behaviors without touching core POEM files.", "context": "After VibeDeck research exploring image generation workflows with multiple dimensions (product photography, skins, design variations, manufacturing). Wanted to add knowledge islands (docs/model-research/, manufacturing-analysis/, design-variations/) and extend Penny's command set for workflow-specific tasks. Implemented workaround by modifying .poem-core/poem-core-config.yaml to add 'vibedeck-kickstarter-images' workflow with 6 reference materials (priority 5-30), documented in docs/poem-configuration-changes.md. This works but still requires modifying core POEM files.", "expected": "Extension mechanism allowing: 1) Workflow-specific knowledge bases registered without modifying poem-core-config.yaml. 2) Custom agent commands/behaviors layered on top of core agents. 3) Project-specific agent extensions that don't pollute core POEM. 4) Clear separation between 'POEM core' and 'project customizations'. Similar to how BMAD itself might handle extensions (unknown if BMAD has this pattern). Possibly poem/workflows/[name]/config.yaml that extends core config without modifying it.", "actual": "To add workflow-specific capabilities, must modify: 1) .poem-core/poem-core-config.yaml (add workflow with referenceMaterials array, each with path/priority/purpose). 2) Penny agent definition (add new commands). No separation between core and project-specific extensions. Current implementation: Added 'vibedeck-kickstarter-images' workflow directly in .poem-core/ with 6 reference sources prioritized 5-30 (model-research:30, manufacturing-analysis:25, design-variations:20, skins:15, reference-images:10, image-generation:5).", "impact": "Projects can't customize agents for their domain without forking/modifying core POEM. Upgrades to POEM core would overwrite customizations. No way to share project-specific agent extensions. Unclear how BMAD itself handles this pattern - may need research into BMAD extension mechanisms. Current workaround demonstrates the pattern needed (workflows with prioritized reference materials) but lacks proper extension boundary.", "tags": ["architecture", "agents", "extensibility", "plugins", "epic-6"], "references": {"files": [".poem-core/poem-core-config.yaml", ".claude/commands/poem/agents/penny.md", "docs/model-research/", "vibedeck-mocks/manufacturing-analysis/", "vibedeck-mocks/design-variations/", "vibedeck-mocks/skins/", "vibedeck-mocks/reference-images/", "docs/image-generation/", "docs/poem-configuration-changes.md"], "docs": ["docs/prd.md#epic-6", "docs/architecture.md"]}, "additional_notes": "Example use case: VibeDeck needs Penny to reference model-research knowledge (FLUX.2 vs DALL-E 3 selection), manufacturing feasibility analysis, and design concept notes. Commands like *model-suggest, *dimension, *manufacturing-check are workflow-specific, not universal. Question: Does BMAD have an extension pattern for this? Should POEM learn from it? Implemented pattern shows workflows can have referenceMaterials with priority levels - this could be the basis for plugin system where project-level config merges with core config.", "suggestedEpic": "Epic 0", "suggestedStory": null, "epicRationale": "Architectural gap discovered during real-world usage requiring extensibility patterns for agent customization"}
{"timestamp": "2026-01-15T15:10:00Z", "session": "vibedeck-usage-2026-01-15", "category": "docs-gap", "severity": "high", "observation": "POEM lacks conceptual model and documentation for 'prompt templates' vs 'prompt instances'. SupportSignal example shows prompts folder contains meta-templates like 'Analysis Classification Example', 'Analysis Observation Example', 'Analysis Predicate Example' that are not executable prompts but patterns for creating multiple similar prompts. Use case: Angela provided 3 predicates - unclear whether to: (1) embed logic directly in template file, or (2) use template to generate 3 new prompt files. Both approaches work but POEM has no documented pattern for template-based prompt creation, file naming conventions, folder structure (templates/ vs prompts/), or Penny commands for template instantiation.", "context": "Working with SupportSignal incident workflows. Looking at poem/prompts/ folder containing 'Analysis Predicate Example' and other '*Example' files that are templates, not prompts. Needed to create 3 predicate prompts from Angela's requirements.", "expected": "1) Clear distinction: 'prompt template' (meta-pattern) vs 'prompt' (executable instance). 2) File naming convention (e.g., *.template.hbs for templates). 3) Folder structure: poem/templates/ and poem/prompts/, or poem/prompts/templates/. 4) Penny commands for template-based creation: *create-from-template <template-name> <instance-name>. 5) Documentation explaining when to use templates vs single prompts. 6) Schema/metadata indicating 'this is a template' vs 'this is an instance'.", "actual": "Templates and prompts coexist in same folder with no distinguishing markers except 'Example' in name (informal convention). No documentation on template pattern. No Penny commands for template instantiation. Unclear whether instances should be new files or embedded in template.", "impact": "Confusing for users creating similar prompts - no guidance on when to use templates. Risk of inconsistent patterns (some embed logic, some create instances). Harder to discover/reuse templates. No way to validate 'is this a template or prompt'. Penny can't help with template-based workflows.", "tags": ["documentation", "conceptual-model", "prompts", "templates", "epic-2", "epic-6"], "references": {"files": ["poem/prompts/analysis-classification-example.hbs", "poem/prompts/analysis-observation-example.hbs", "poem/prompts/analysis-predicate-example.hbs"], "docs": ["docs/prd.md#epic-2", "docs/architecture.md"]}, "additional_notes": "Real-world pattern from SupportSignal: Templates are reusable structures (predicate pattern, classification pattern, observation pattern). Instances are specific implementations (is-violent-incident predicate, is-medication-incident predicate, etc.). Need to decide: 1) Are templates first-class citizens in POEM? 2) Should poem/templates/ be a separate workspace folder? 3) Should templates have schema metadata: {isTemplate: true, templateType: 'predicate'}? 4) Does Epic 2 (prompt authoring) cover this, or is it a gap?", "suggestedEpic": "Epic 0", "suggestedStory": null, "epicRationale": "Documentation gap discovered during usage affecting prompt authoring patterns and template management"}
{"timestamp": "2026-01-20T10:00:00Z", "session": "poem-installation-2026-01-20", "category": "bug", "severity": "critical", "observation": "POEM installer offers to overwrite poem/ user workspace directory during reinstallation, causing data loss. When existing installation detected, prompt shows '[O]verwrite, [M]erge (preserve poem/), or [C]ancel?' but this applies to ALL directories including poem/. User selected [O]verwrite expecting it to apply only to framework files (.poem-core, .poem-app, .claude/commands/poem), not realizing it would delete user data in poem/. The poem/ directory should NEVER be offered for overwrite - it contains user-created prompts, schemas, workflows, and configurations that must always be preserved.", "context": "Running 'npx poem-os install' in supportsignal project after Stories 1.7 and 1.8 added reinstallation capabilities. Existing installation had .poem-core, .poem-app, poem, and .claude/commands/poem. User selected 'o' to overwrite, expecting framework refresh, not data deletion.", "expected": "Installer should always preserve poem/ directory. Overwrite/merge options should ONLY apply to framework files (.poem-core, .poem-app, .claude/commands/poem). The prompt should clearly indicate 'Overwriting framework files (.poem-core, .poem-app, .claude/commands/poem)', never mentioning poem/. User workspace data must be protected at all costs.", "actual": "The overwrite/merge prompt groups framework files with user workspace. Selecting [O]verwrite deletes poem/ directory. Even [M]erge option mentioning 'preserve poem/' is insufficient - the mere presence of poem/ in the prompt suggests it's safe to overwrite, creating misleading UX that led to data loss.", "impact": "Critical data loss: All user-created prompts, schemas, workflows, configurations, and project-specific customizations in poem/ directory were deleted. Reinstallation workflow fundamentally broken - users cannot safely upgrade POEM framework. Blocks adoption of Story 1.7/1.8 features. Erodes trust in installer.", "tags": ["installer", "data-loss", "critical", "story-1.7", "story-1.8", "ux", "user-workspace"], "references": {"files": ["packages/poem-app/src/commands/install.ts", "poem/"], "commands": ["npx poem-os install"], "docs": ["docs/stories/1.7.story.md", "docs/stories/1.8.story.md"]}, "additional_notes": "The [M]erge option is a band-aid that doesn't address root cause. The architectural fix: poem/ should be treated as sacred user space that is NEVER touched by installer operations. Framework updates (overwrite/merge) should be scoped exclusively to .poem-core, .poem-app, and .claude/commands/poem. Consider adding explicit safety check: refuse to proceed if 'o' selected and poem/ contains any files. Better: remove poem/ from detection/prompt entirely - it's not part of 'existing installation' from installer's perspective.", "suggestedEpic": "Epic 1", "suggestedStory": "Story 1.9", "epicRationale": "Installation foundation work completing Epic 1's scaffolding goals by protecting user workspace during reinstall", "resolution": {"status": "fixed", "fixedIn": "Story 1.9", "fixedDate": "2026-01-20T00:00:00Z", "fixDescription": "Implemented .poem-preserve preservation system (like .gitignore) with default rules protecting poem/, dev-workspace/, and .poem-app/.env. Added auto-migration for existing installations. Added confirmation prompt with categorized summary showing what will be updated vs preserved.", "verifiedBy": "David Cruwys"}}
{"timestamp": "2026-01-20T10:05:00Z", "session": "poem-installation-2026-01-20", "category": "docs-gap", "severity": "medium", "observation": "User confusion about agent 'Tyler' - whether it exists, and if so, whether it's a BMAD agent or POEM agent. Search shows no agent named Tyler exists in POEM codebase (.claude/commands/poem/agents/, .poem-core/agents/, or documentation). This suggests either: (1) missing documentation listing all available POEM agents, (2) user expected an agent that doesn't exist, or (3) name confusion between POEM and BMAD agent rosters.", "context": "User asked 'Do we have an agent called Tyler?' after working with POEM installation and discussing Story 1.7/1.8. No context for where Tyler reference came from.", "expected": "Clear documentation showing: (1) Complete POEM agent roster (Penny, Victor, others?). (2) Complete BMAD agent roster (SM/Bob, Dev/James, QA/Quinn, Architect, PM, PO, Analyst, UX Expert, etc.). (3) Easy way to list available agents via command or docs reference.", "actual": "No Tyler agent exists. No centralized agent directory in user-facing docs. CLAUDE.md mentions POEM agents (Penny, Victor) and BMAD agents, but no comprehensive roster. User has no quick way to verify 'does agent X exist?'", "impact": "Users may waste time searching for non-existent agents or be unaware of available agents. Confusion between BMAD agent names (10 agents) and POEM agent names (2-3 agents). No discovery mechanism for 'what agents can I use?'", "tags": ["documentation", "agents", "discovery", "epic-6"], "references": {"docs": ["docs/prd.md#epic-6", "CLAUDE.md", ".bmad-core/agents/"]}, "additional_notes": "POEM has 2 documented agents: Penny (Prompt Engineer) and Victor (Capability Progression Validator). BMAD has 10 agents: SM, Dev, QA, Architect, PM, PO, Analyst, UX Expert, BMAD Master, BMAD Orchestrator. Need docs clarifying: (1) POEM agents are domain-specific for prompt engineering workflows, (2) BMAD agents are for software development lifecycle, (3) How to list available agents. Consider adding '/poem/agents/list' or 'poem-os agents' command.", "suggestedEpic": "Epic 4", "suggestedStory": null, "epicRationale": "Workflow validation gap affecting agent discovery and schema validation for available agents"}
{"timestamp": "2026-01-20T10:10:00Z", "session": "poem-installation-2026-01-20", "category": "missing-feature", "severity": "high", "observation": "Schemas lack input/output property distinction. User believes POEM was designed to support separate input and output properties in schemas, but generated schema only has generic 'properties' section. For prompt engineering workflows, it's critical to distinguish between: (1) input properties (data fed INTO the prompt), and (2) output properties (structured data RETURNED by the AI). Current schema structure treats all properties equally with no role designation. This may be a missing implementation, incomplete feature, or misunderstanding of intended design.", "context": "Examining 'Incident Details' schema generated during SupportSignal workflow. Schema has standard JSON Schema structure with properties array but no input/output metadata or separation. User recalls that application changes were made to support inputs/outputs in schemas.", "expected": "Schema structure should distinguish input vs output properties. Possible implementations: (1) Separate top-level keys: {inputProperties: {...}, outputProperties: {...}}, (2) Property-level metadata: each property has 'role': 'input' or 'role': 'output', (3) Separate input.schema.json and output.schema.json files, (4) Custom JSON Schema extension with x-poem-role or similar. Documentation should clarify which pattern POEM uses.", "actual": "Schema uses standard JSON Schema Draft 07 with single 'properties' object. No distinction between input and output properties. No role metadata. No x-poem extensions visible. All 6 properties (reporter_name, participant_name, participant_id, event_date_time, site_id, location) treated identically.", "impact": "Cannot distinguish what data goes into prompt vs what comes out. Prompts often have different input/output schemas (e.g., input: raw transcript, output: structured incident details). Mock data generation unclear about which properties to generate. Validation unclear about which direction to validate. Mapping between input/output schemas cannot be expressed. This is fundamental to prompt engineering workflows.", "tags": ["schemas", "architecture", "missing-feature", "epic-3", "input-output"], "references": {"files": ["poem/schemas/incident-details.schema.json"], "docs": ["docs/prd.md#epic-3", "docs/architecture.md"]}, "additional_notes": "User specifically mentions 'we made changes in the application to support inputs and outputs' - suggests this was planned or partially implemented but may not be working/complete. Need to investigate: (1) Was this feature implemented? Where? (2) Is there documentation on how to use it? (3) Does Penny support creating schemas with input/output distinction? (4) Do other POEM components (mock data, validation, mapping) understand input/output roles? Example use case: SupportSignal incident workflow takes raw shift notes as INPUT and produces structured incident details as OUTPUT - these are different schemas.", "suggestedEpic": "Epic 2", "suggestedStory": null, "epicRationale": "Schema authoring feature gap affecting prompt template input/output parameter definitions"}
{"timestamp": "2026-01-20T10:15:00Z", "session": "poem-installation-2026-01-20", "category": "usability", "severity": "critical", "observation": "Installation upgrade prompt lacks granular control and clarity for different folder types. When existing installation detected, prompt shows 'Existing installation detected: .poem-core, .poem-app, poem, .claude/commands/poem - [O]verwrite, [M]erge (preserve poem/), or [C]ancel?' This groups all folders together but they have different preservation requirements: (1) .poem-core can be upgraded each time, (2) .poem-app could be upgraded but may have custom integrations in future, (3) poem/ should NEVER be modified (user data), (4) Within .poem-core itself, some files shouldn't be touched (.env with API keys, astro.config.mjs with custom config, dev-workspace docs). The prompt doesn't provide per-folder control or document what happens to each folder type.", "context": "Running 'npx poem-os install' when .poem-core, .poem-app, poem, and .claude/commands/poem already exist. Installer detected differences like: .env file content (API keys/config), astro.config.mjs (configuration changes), build artifacts (.astro/, .vite/), missing dev-workspace docs (SESSION-PROGRESS-2026-01-16.md, incident-analysis-test-results.md).", "expected": "(1) Per-folder granular control: separate prompts for .poem-core, .poem-app, poem, .claude/commands/poem. (2) Clear documentation of upgrade strategy for each folder. (3) Intelligent defaults: always preserve poem/, merge configs, overwrite framework code. (4) File-level awareness: preserve .env, preserve dev-workspace docs, regenerate build artifacts, merge astro.config.mjs. (5) Upgrade guide explaining what happens to each folder/file type during reinstall.", "actual": "Single yes/no prompt for all folders. No granularity. User must choose one strategy (overwrite/merge/cancel) for everything. No documentation on what gets preserved vs overwritten. No intelligent handling of user data vs framework files vs configs vs build artifacts.", "impact": "Risk of data loss (poem/ directory, .env files, dev-workspace docs, custom configs). Users cannot safely upgrade POEM framework. Forces manual backup/restore workflows. Blocks adoption of bugfixes and new features because reinstall is dangerous. Users don't understand what will happen if they choose overwrite vs merge.", "tags": ["installation", "upgrade", "usability", "configuration", "data-preservation", "epic-1", "story-1.7", "story-1.8"], "references": {"commands": ["npx poem-os install"], "files": [".env", "astro.config.mjs", "dev-workspace/SESSION-PROGRESS-2026-01-16.md", "dev-workspace/incident-analysis-test-results.md", ".poem-core/", ".poem-app/", "poem/", ".claude/commands/poem/"], "docs": ["docs/stories/1.7.story.md", "docs/stories/1.8.story.md"]}, "additional_notes": "This issue compounds the critical bug (issue #6) where poem/ can be overwritten. Even if poem/ is protected, .poem-core still has mixed content (framework + user data like dev-workspace docs + config). Need architectural clarity: (1) What is framework (always safe to overwrite)? (2) What is user config (merge/preserve)? (3) What is user data (never touch)? (4) What are build artifacts (regenerate)? Consider per-folder upgrade strategies: .poem-core \u2192 smart merge (preserve .env, dev-workspace/), .poem-app \u2192 overwrite (regenerate build artifacts), poem/ \u2192 never touch, .claude/commands/poem/ \u2192 overwrite.", "suggestedEpic": "Epic 1", "suggestedStory": "Story 1.9", "epicRationale": "Installation foundation work completing Epic 1's scaffolding goals with granular upgrade control", "resolution": {"status": "fixed", "fixedIn": "Story 1.9", "fixedDate": "2026-01-20T00:00:00Z", "fixDescription": "Implemented preservation system with .poem-preserve file allowing granular control. Users can customize rules for per-folder/per-file control. Installation prompt shows categorized breakdown of Updates vs Preserved items.", "verifiedBy": "David Cruwys"}}
{"timestamp": "2026-01-20T10:20:00Z", "session": "poem-installation-2026-01-20", "category": "missing-feature", "severity": "critical", "observation": "Installer lacks preservation ruleset (like .gitignore) defining which files/folders must never be touched during upgrades. Currently treats all directories uniformly - no architectural concept of 'framework files' (safe to overwrite) vs 'user data' (must preserve) vs 'config files' (merge/preserve) vs 'build artifacts' (regenerate). This causes the installer to offer overwriting user data (poem/ directory, .env files, dev-workspace docs) alongside framework code. Need something like .poempreserve or built-in preservation rules that installer respects during all operations.", "context": "During 'npx poem-os install' reinstallation, installer detected .poem-core, .poem-app, poem, .claude/commands/poem and offered single overwrite/merge choice for all. Within these folders are mixed content types: .env files (API keys - preserve), astro.config.mjs (user config - merge), dev-workspace docs (user data - preserve), build artifacts (regenerate), framework code (overwrite), poem/ directory (never touch). Installer has no concept distinguishing these.", "expected": "(1) Preservation manifest file (.poempreserve or embedded in poem-core-config.yaml) listing patterns to never touch: poem/**, .env, dev-workspace/**/*.md, custom configs. (2) Installer reads preservation rules and excludes protected files from overwrite operations. (3) Clear categories: 'framework' (overwritable), 'user-data' (preserved), 'config' (mergeable), 'generated' (regeneratable). (4) Per-file/folder upgrade strategy based on classification. (5) Documentation on preservation rules and how to extend them.", "actual": "No preservation rules. All directories/files treated equally. Overwrite operation is all-or-nothing. User must manually identify what needs protection and create backups. No concept of 'this should never be touched by installer'. Installer logic doesn't distinguish between code and data.", "impact": "Critical: enables data loss scenarios like issue #6 where poem/ was offered for overwrite. Makes safe upgrades impossible - users must manually protect their data. No way to express 'these files are sacred'. Forces choice between 'lose my data' or 'never upgrade'. Architectural gap prevents safe automated upgrade workflows. This is the root cause of issues #6, #9, and upgrade friction.", "tags": ["installation", "upgrade", "architecture", "data-preservation", "preservation-rules", "critical", "epic-1", "story-1.7", "story-1.8"], "references": {"files": [".env", "astro.config.mjs", "dev-workspace/", "poem/", ".poem-core/", ".poem-app/"], "commands": ["npx poem-os install"], "docs": ["docs/stories/1.7.story.md", "docs/stories/1.8.story.md"]}, "additional_notes": "Pattern similar to .gitignore but for installation operations. Example preservation rules: poem/** (never touch user workspace), **/.env (preserve secrets), **/dev-workspace/**/*.md (preserve user docs), **/*.config.js (merge, don't overwrite), **/.astro/ (regenerate, safe to delete), **/node_modules/ (regenerate). Could be implemented as: (1) .poempreserve file in project root, (2) preservationRules in poem-core-config.yaml, (3) Hardcoded rules in installer with override capability. Installer should fail-safe: if preservation rules exist, default to preserving unless explicitly told to overwrite.", "suggestedEpic": "Epic 1", "suggestedStory": "Story 1.9", "epicRationale": "Installation foundation work completing Epic 1's scaffolding goals with preservation ruleset architecture", "resolution": {"status": "fixed", "fixedIn": "Story 1.9", "fixedDate": "2026-01-20T00:00:00Z", "fixDescription": "Implemented .poem-preserve preservation ruleset (like .gitignore) with default rules for poem/, dev-workspace/, and .poem-app/.env. Installer respects preservation rules during all operations. Auto-migration adds missing rules to existing .poem-preserve files.", "verifiedBy": "David Cruwys"}}
{"timestamp": "2026-01-22T00:00:00Z", "session": "poem-installer-2026-01-22", "category": "bug", "severity": "medium", "observation": "Registry cleanup issue: stale registry entries for deleted installations are not automatically removed. When installations are manually deleted from disk (e.g., /Users/davidcruwys/dev/x, /Users/davidcruwys/dev/x/aa), their registry entries persist in ~/.poem/registry.json. The registry continues to list ports 9530 and 9540 as 'in use' even though these installations no longer exist. While 'npx poem-os registry --cleanup' exists to manually remove stale entries, there's no automatic detection/cleanup during installation.", "context": "User manually deleted test installations at /Users/davidcruwys/dev/x (port 9530) and /Users/davidcruwys/dev/x/aa (port 9540). When running new installation, installer showed these ports as 'already in use' in the registry display (ports 9500, 9510, 9520, 9530, 9540). Registry entries were false positives - directories no longer existed.", "expected": "(1) Installer automatically detects missing installation directories during port conflict check. (2) Invalid registry entries are silently ignored or auto-removed. (3) User sees only valid installations in 'Registered POEM installations' list. (4) Optional: installer offers 'Clean up X missing installations?' prompt before port selection.", "actual": "checkPortConflict() in bin/utils.js checks registry but doesn't validate that installation.path exists. Stale entries are treated as active. User must manually run 'npx poem-os registry --cleanup' to remove false entries. Port selection UX shows misleading information (5 installations listed, only 3 actually exist).", "impact": "Minor: Registry gets polluted with stale entries over time. Confusing UX showing 'already in use' for deleted installations. Suggested available ports may skip valid ports due to false conflicts. Users unaware of 'registry --cleanup' command get degraded experience. Not critical because manual cleanup works and user can override suggestions.", "tags": ["registry", "installation", "cleanup", "port-management", "epic-1"], "references": {"files": ["bin/utils.js", "bin/install.js", "~/.poem/registry.json"], "functions": ["checkPortConflict", "promptForPort"], "commands": ["npx poem-os registry --cleanup"], "docs": ["docs/stories/1.7.story.md"]}, "additional_notes": "Proposed fix: In checkPortConflict(), add existence check using fs.existsSync(path.join(installation.path, '.poem-app')). If missing, skip conflict (or optionally remove from registry). Alternative: Add auto-cleanup at start of install command - silently remove stale entries before port selection. Trade-off: auto-removal may surprise users who temporarily unmounted drives or moved installations. Conservative approach: detect + display warning, let user run --cleanup manually.", "schemaVersion": "2.0", "estimatedTime": "<1hr", "thematicArea": "installation", "type": "bug", "suggestedPath": "Quick Fix", "suggestedPathRationale": ["Simple validation check in checkPortConflict() function", "Single-file change in bin/utils.js", "No ceremony needed - straightforward bug fix"], "suggestedEpic": "Epic 0"}
{"timestamp": "2026-01-22T00:05:00Z", "session": "poem-installer-2026-01-22", "category": "bug", "severity": "high", "observation": "Port reuse blocked by stale registry entries. When user attempts to reuse a port from a deleted installation (e.g., 9530), installer rejects it with 'Port 9530 is already in use' even though the installation no longer exists. The port conflict check (checkPortConflict in bin/utils.js) validates against registry entries but doesn't verify that the installation directory still exists. This blocks legitimate port reuse and forces users to pick new ports or manually run 'npx poem-os registry --cleanup' before installation.", "context": "User manually deleted installations at /Users/davidcruwys/dev/x (port 9530) and /Users/davidcruwys/dev/x/aa (port 9540). When attempting to install at new location and manually entering port 9530, installer showed error: 'Port 9530 is already in use' with registry listing showing the deleted installation path. User had to abandon port reuse attempt.", "expected": "(1) checkPortConflict() validates that installation.path exists on disk before considering it a conflict. (2) If installation directory doesn't exist, port is considered available. (3) User can reuse ports from deleted installations without manual cleanup. (4) Installer automatically cleans stale entries when conflict check fails existence validation.", "actual": "checkPortConflict() only checks registry.installations array for matching port. No existence validation of installation.path. Stale registry entries are treated as active conflicts. User cannot reuse ports without running 'npx poem-os registry --cleanup' first. Installation workflow unnecessarily blocked.", "impact": "High: Blocks legitimate port reuse after deleting installations. Forces workaround (manual cleanup command) that most users won't know about. Creates frustration when trying to reclaim ports. Degrades UX for users managing multiple POEM installations. Compounds Issue #11 (stale registry entries) by making stale entries actively block operations, not just pollute display.", "tags": ["registry", "installation", "port-management", "port-reuse", "bug", "epic-1"], "references": {"files": ["bin/utils.js", "bin/install.js", "~/.poem/registry.json"], "functions": ["checkPortConflict", "promptForPort", "validatePortWithConflictCheck"], "commands": ["npx poem-os install"], "docs": ["docs/stories/1.7.story.md"]}, "additional_notes": "This is the more severe aspect of Issue #11. While #11 is about registry display pollution (medium severity), this issue blocks operations (high severity). Root cause is identical: checkPortConflict() doesn't validate installation existence. Proposed fix: Add fs.existsSync(path.join(installation.path, '.poem-app')) check in checkPortConflict(). If missing, return {conflict: false} and optionally remove stale entry. This would fix both #11 and #12 simultaneously. Code location: bin/utils.js lines 287-305, checkPortConflict function. Simple 3-line fix: check if path exists before returning conflict.", "schemaVersion": "2.0", "estimatedTime": "<1hr", "thematicArea": "installation", "type": "bug", "suggestedPath": "Quick Fix", "suggestedPathRationale": ["Single function modification in checkPortConflict()", "Add existsSync() validation before returning conflict", "No tests needed - straightforward existence check"], "suggestedEpic": "Epic 0"}
{"timestamp": "2026-01-22T00:10:00Z", "session": "poem-installer-2026-01-22", "category": "missing-feature", "severity": "medium", "observation": "No centralized semantic versioning system for POEM releases. Version numbers are scattered across multiple files (package.json files, README.md, bin/install.js VERSION constant, possibly others) with no automated mechanism to bump versions consistently. When creating releases or updating versions, developers must manually update each location, risking inconsistencies where different files show different version numbers. Need a centralized system that understands semantic versioning (major.minor.patch) and can bump versions across all relevant files atomically.", "context": "During post-implementation documentation of Story 1.8 fixes (versions 1.2.1, 1.2.2), noticed version numbers are managed manually in story change logs. No clear process for bumping POEM framework versions. Multiple locations track versions: bin/install.js has VERSION constant, package.json files exist in monorepo structure (packages/poem-app, packages/poem-core), README shows version, NPX installation references version.", "expected": "(1) Single source of truth for POEM version number. (2) CLI command or agent task to bump versions: 'npx poem-os version --patch', 'npx poem-os version --minor', 'npx poem-os version --major'. (3) Automated updates to all version references: package.json files, README.md, bin/install.js VERSION constant, any other docs mentioning version. (4) Possibly integrate with existing BMAD agent (PO, PM, or Architect) with instructions for version management. (5) Follow semantic versioning spec (semver.org): major = breaking changes, minor = new features, patch = bug fixes.", "actual": "Versions managed manually. No tooling for consistent version bumps. Developers must remember all files containing version numbers and update each one. Easy to miss files or create version mismatches. No semantic versioning guidance integrated into workflow.", "impact": "Risk of version number inconsistencies across files. Manual version management is error-prone and time-consuming. No clear process for determining whether to bump major/minor/patch. Difficult to track what version introduced which features. NPX installation may reference wrong version. README may be out of sync with actual package version.", "tags": ["versioning", "semantic-versioning", "release-management", "automation", "tooling", "epic-0"], "references": {"files": ["bin/install.js", "package.json", "packages/poem-app/package.json", "packages/poem-core/package.json", "README.md", "CHANGELOG.md"], "commands": ["npm version"], "docs": ["https://semver.org/", "docs/stories/1.8.story.md"]}, "additional_notes": "This is more of a developer experience / release engineering issue than a user-facing feature. Might be worth researching existing tools: npm version (built-in), standard-version, semantic-release, changesets. Could be as simple as a shell script that updates all relevant files, or could integrate with BMAD workflow (e.g., PO agent has *release command that prompts for version bump type and updates all files + creates git tag). Not urgent but will become more important as POEM matures and has more users. Current workaround: manually update version in each file, hope nothing is missed.", "schemaVersion": "2.0", "estimatedTime": "4-8hr", "thematicArea": "developer-tooling", "type": "enhancement", "suggestedPath": "Epic 0 Story", "suggestedPathRationale": ["Requires multi-file coordination and automation", "Research phase needed to evaluate existing tools (npm version, standard-version, etc.)", "Full ceremony beneficial for release management infrastructure"], "suggestedEpic": "Epic 0"}
{"timestamp": "2026-01-22T00:15:00Z", "session": "poem-installer-2026-01-22", "category": "missing-feature", "severity": "low", "observation": "No convenient way to manually edit or inspect registry file. Registry stored at ~/.poem/registry.json but users have no quick command to open it for manual editing. When registry has issues (duplicate ports, stale entries that should be cleaned up, incorrect data), users must either: (1) run 'npx poem-os registry --cleanup' which only removes missing installations, or (2) manually navigate to ~/.poem/registry.json and open in editor. Need a simple command or skill to open registry file in user's default editor for manual inspection and correction.", "context": "After installing POEM and seeing registry display during port selection. Registry showed duplicate port 9530 (listed for both stale 'x' installation and active 'v-appydave' installation), port 9510 marked as stale but actually exists (poem-os directory exists), and other inconsistencies. User wants to manually clean up registry but finding and opening ~/.poem/registry.json is cumbersome.", "expected": "(1) Command: 'npx poem-os registry --edit' opens ~/.poem/registry.json in $EDITOR or default system editor. (2) Alternative: '/poem/skills/edit-registry' slash command/skill that opens file. (3) Command: 'npx poem-os registry --path' prints registry file location for easy copy/paste. (4) Help text documents where registry is stored (already exists in 'registry --list' but should be in --help too). (5) After manual edits, registry is validated (JSON syntax, required fields) and optionally refreshed with 'registry --health'.", "actual": "Users must remember ~/.poem/registry.json path and manually open in editor. No convenience command. 'registry --cleanup' only removes missing entries, doesn't help with duplicates or incorrect data. No validation after manual edits.", "impact": "Minor friction when needing to manually fix registry issues. Increases likelihood of JSON syntax errors when editing (no validation). Users may not know where registry is stored. Most users won't need this often, but when they do, current UX is cumbersome. Workaround: open ~/.poem/registry.json manually, edit carefully, validate JSON, run 'registry --health' to verify.", "tags": ["registry", "tooling", "developer-experience", "convenience", "epic-1"], "references": {"files": ["~/.poem/registry.json", "bin/install.js"], "commands": ["npx poem-os registry --list", "npx poem-os registry --cleanup", "npx poem-os registry --health"], "docs": ["docs/stories/1.8.story.md"]}, "additional_notes": "This is a low-priority convenience feature. Most registry issues should be handled automatically (Issue #11/#12 fixed stale entry blocking). However, edge cases exist where manual editing is needed: duplicate port assignments, incorrect installation IDs, corrupted metadata, testing/debugging registry behavior. Implementation options: (1) Simple: 'registry --edit' spawns $EDITOR with registry path (5 lines of code). (2) Advanced: Interactive TUI editor with validation (overkill). (3) Skill: '/poem/skills/edit-registry' that uses Claude Code's file editing. For now, documenting registry location in README and --help may be sufficient. Consider this a 'nice to have' rather than critical feature.", "schemaVersion": "2.0", "estimatedTime": "<1hr", "thematicArea": "registry", "type": "enhancement", "suggestedPath": "Quick Fix", "suggestedPathRationale": ["Very simple implementation - spawn editor with registry path", "Single command addition to handleRegistry()", "No complex logic or testing needed"], "suggestedEpic": "Epic 0"}
