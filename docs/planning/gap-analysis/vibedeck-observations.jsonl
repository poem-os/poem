{"timestamp":"2026-01-15T14:30:00Z","session":"vibedeck-usage-2026-01-15","category":"missing-feature","severity":"high","observation":"Installation creates dev-workspace in wrong location (.poem-app/dev-workspace) and poem/ workspace doesn't follow multi-workflow folder structure pattern. Dev workspace should only exist during POEM development (in packages/poem-core/), not in production installs. Additionally, installed poem/ directory has flat structure (poem/prompts/, poem/schemas/, poem/config/) instead of multi-workflow pattern (poem/workflows/[workflow-name]/{config,prompts,schemas,workflow-data}/) that's used in dev-workspace.","context":"After running 'poem-os install' in vibedeck project. Installer created .poem-app/dev-workspace/ (unexpected) and poem/ workspace with flat structure.","expected":"1) No dev-workspace in production installs. 2) poem/workflows/[workflow-name]/ structure matching dev-workspace pattern. 3) Possibly a starter workflow created during install (Epic 1.6/1.7).","actual":"1) .poem-app/dev-workspace/ created in production install. 2) poem/ has flat structure: poem/prompts/, poem/schemas/, poem/config/, poem/workflow-data/, poem/mappings/, poem/mock-data/, poem/templates/, poem/archive/. 3) No workflow-specific folders.","impact":"Multi-workflow projects can't organize prompts/schemas/config by workflow. No clear path to add new workflows with proper folder structure. Confusion about whether dev-workspace should exist in production.","tags":["installation","folder-structure","multi-workflow","epic-1","epic-5","epic-6"],"references":{"files":[".poem-app/dev-workspace/","poem/","packages/poem-core/dev-workspace/workflows/nano/","packages/poem-core/dev-workspace/workflows/banana/","packages/poem-core/dev-workspace/workflows/youtube-launch-optimizer/"],"commands":["poem-os install"],"docs":["docs/stories/story-1.6.md","docs/stories/story-1.7.md","docs/stories/story-3.7.md","docs/prd.md#epic-4","docs/prd.md#epic-5","docs/prd.md#epic-6"]},"additional_notes":"Uncertainty about which epic should own 'add workflow' capability: Epic 1 (installation), Epic 5 (workflow management), or Epic 6 (agents). This might need a dedicated command or agent feature. Pattern shows each workflow needs: config/, prompts/, schemas/, workflow-data/ subdirectories."}
{"timestamp":"2026-01-15T14:45:00Z","session":"vibedeck-usage-2026-01-15","category":"usability","severity":"medium","observation":"Port configuration during installation uses wrong defaults and increment pattern. Installer defaults to port 4321 and suggests sequential increments (4322, 4323, etc.). Desired pattern: default 9500, increment by 10 (9510, 9520, 9530...). When installing second POEM instance, installer suggested 4322 instead of detecting it's a second install and suggesting 9510. Port selection should be intelligent about multi-instance scenarios.","context":"Installation prompt 'What port should POEM run on? (default: 4321):' during vibedeck and supportsignal installs. User manually entered 9500 for supportsignal.","expected":"1) Default port: 9500 (not 4321). 2) Suggested ports increment by 10: 9510, 9520, 9530, 9540, 9550. 3) For second install, detect existing instance and suggest next port in sequence (9510). 4) Installation prompt should mention recommended range.","actual":"1) Default: 4321. 2) Suggestions shown: 4322, 4323, 5321, 8321. 3) No detection of existing POEM installations. 4) Increment pattern is +1, not +10.","impact":"Users installing multiple POEM instances get wrong port suggestions and have to manually calculate port numbers. No guidance on port numbering strategy. Creates inconsistent port assignments across projects.","tags":["installation","configuration","port","multi-instance","epic-1"],"references":{"commands":["poem-os install"],"docs":["docs/stories/story-1.7.md"]},"additional_notes":"User wants starting range around 9500 but open to research on best port range. Installer logic should be deterministic (not LLM-based). Consider: 1) Scanning for existing .poem-app/ installations to suggest next port. 2) Storing last-used port globally. 3) Validation that port is available. Port range 9500-9999 gives ~50 installations with +10 increment."}
{"timestamp":"2026-01-15T14:50:00Z","session":"vibedeck-usage-2026-01-15","category":"bug","severity":"high","observation":"Slash command uses role name instead of agent name. Installation instructions show '/poem/agents/prompt-engineer' but agent should be accessed by name: '/penny' or '/poem/agents/penny'. Prompt engineering is the umbrella role Penny performs (create agent, create prompt, refine prompt, create workflow, add to workflow, etc.), but activation is by agent name, not role. This was thought to be already fixed based on previous agent mapping work with Claude Code.","context":"Post-installation output showing 'Slash Commands: /poem/agents/prompt-engineer - Activate Prompt Engineer agent'.","expected":"Slash command shown as '/penny' or '/poem/agents/penny'. Instructions should reference agent by name (Penny), not by role (prompt-engineer).","actual":"Installation output shows '/poem/agents/prompt-engineer'. Using role as command identifier instead of agent name.","impact":"Confusing UX - users learn wrong command syntax. Inconsistent with agent naming convention. Makes it harder to remember which agent does what if referenced by role instead of persona name.","tags":["agents","slash-commands","installation","naming","claude-code-integration","epic-6"],"references":{"commands":["/poem/agents/prompt-engineer","/penny","/poem/agents/penny"],"files":[".claude/commands/poem/agents/penny.md"],"docs":["docs/prd.md#epic-6"]},"additional_notes":"Previous work established agent names (Penny) map to Claude Code slash commands. This regression suggests installer or command registration isn't using correct agent name mappings. All agents should follow this pattern: /[agent-name] as primary, /poem/agents/[agent-name] as alternative."}
{"timestamp":"2026-01-15T15:00:00Z","session":"vibedeck-usage-2026-01-15","category":"missing-feature","severity":"critical","observation":"No extension mechanism for usage-specific agent customization. VibeDeck workflow research identified need to extend Penny with domain knowledge (model research, design concepts, manufacturing analysis) and new commands (*model-suggest, *model-compare, *dimension, *manufacturing-check), but this requires modifying POEM core files (.poem-core/poem-core-config.yaml) and core agent (Penny). This feels architecturally wrong - core agents shouldn't be modified for project-specific workflows. Need extension/plugin pattern where projects can add workflow-specific knowledge bases, commands, and agent behaviors without touching core POEM files.","context":"After VibeDeck research exploring image generation workflows with multiple dimensions (product photography, skins, design variations, manufacturing). Wanted to add knowledge islands (docs/model-research/, manufacturing-analysis/, design-variations/) and extend Penny's command set for workflow-specific tasks. Implemented workaround by modifying .poem-core/poem-core-config.yaml to add 'vibedeck-kickstarter-images' workflow with 6 reference materials (priority 5-30), documented in docs/poem-configuration-changes.md. This works but still requires modifying core POEM files.","expected":"Extension mechanism allowing: 1) Workflow-specific knowledge bases registered without modifying poem-core-config.yaml. 2) Custom agent commands/behaviors layered on top of core agents. 3) Project-specific agent extensions that don't pollute core POEM. 4) Clear separation between 'POEM core' and 'project customizations'. Similar to how BMAD itself might handle extensions (unknown if BMAD has this pattern). Possibly poem/workflows/[name]/config.yaml that extends core config without modifying it.","actual":"To add workflow-specific capabilities, must modify: 1) .poem-core/poem-core-config.yaml (add workflow with referenceMaterials array, each with path/priority/purpose). 2) Penny agent definition (add new commands). No separation between core and project-specific extensions. Current implementation: Added 'vibedeck-kickstarter-images' workflow directly in .poem-core/ with 6 reference sources prioritized 5-30 (model-research:30, manufacturing-analysis:25, design-variations:20, skins:15, reference-images:10, image-generation:5).","impact":"Projects can't customize agents for their domain without forking/modifying core POEM. Upgrades to POEM core would overwrite customizations. No way to share project-specific agent extensions. Unclear how BMAD itself handles this pattern - may need research into BMAD extension mechanisms. Current workaround demonstrates the pattern needed (workflows with prioritized reference materials) but lacks proper extension boundary.","tags":["architecture","agents","extensibility","plugins","epic-6"],"references":{"files":[".poem-core/poem-core-config.yaml",".claude/commands/poem/agents/penny.md","docs/model-research/","vibedeck-mocks/manufacturing-analysis/","vibedeck-mocks/design-variations/","vibedeck-mocks/skins/","vibedeck-mocks/reference-images/","docs/image-generation/","docs/poem-configuration-changes.md"],"docs":["docs/prd.md#epic-6","docs/architecture.md"]},"additional_notes":"Example use case: VibeDeck needs Penny to reference model-research knowledge (FLUX.2 vs DALL-E 3 selection), manufacturing feasibility analysis, and design concept notes. Commands like *model-suggest, *dimension, *manufacturing-check are workflow-specific, not universal. Question: Does BMAD have an extension pattern for this? Should POEM learn from it? Implemented pattern shows workflows can have referenceMaterials with priority levels - this could be the basis for plugin system where project-level config merges with core config."}
{"timestamp":"2026-01-15T15:10:00Z","session":"vibedeck-usage-2026-01-15","category":"docs-gap","severity":"high","observation":"POEM lacks conceptual model and documentation for 'prompt templates' vs 'prompt instances'. SupportSignal example shows prompts folder contains meta-templates like 'Analysis Classification Example', 'Analysis Observation Example', 'Analysis Predicate Example' that are not executable prompts but patterns for creating multiple similar prompts. Use case: Angela provided 3 predicates - unclear whether to: (1) embed logic directly in template file, or (2) use template to generate 3 new prompt files. Both approaches work but POEM has no documented pattern for template-based prompt creation, file naming conventions, folder structure (templates/ vs prompts/), or Penny commands for template instantiation.","context":"Working with SupportSignal incident workflows. Looking at poem/prompts/ folder containing 'Analysis Predicate Example' and other '*Example' files that are templates, not prompts. Needed to create 3 predicate prompts from Angela's requirements.","expected":"1) Clear distinction: 'prompt template' (meta-pattern) vs 'prompt' (executable instance). 2) File naming convention (e.g., *.template.hbs for templates). 3) Folder structure: poem/templates/ and poem/prompts/, or poem/prompts/templates/. 4) Penny commands for template-based creation: *create-from-template <template-name> <instance-name>. 5) Documentation explaining when to use templates vs single prompts. 6) Schema/metadata indicating 'this is a template' vs 'this is an instance'.","actual":"Templates and prompts coexist in same folder with no distinguishing markers except 'Example' in name (informal convention). No documentation on template pattern. No Penny commands for template instantiation. Unclear whether instances should be new files or embedded in template.","impact":"Confusing for users creating similar prompts - no guidance on when to use templates. Risk of inconsistent patterns (some embed logic, some create instances). Harder to discover/reuse templates. No way to validate 'is this a template or prompt'. Penny can't help with template-based workflows.","tags":["documentation","conceptual-model","prompts","templates","epic-2","epic-6"],"references":{"files":["poem/prompts/analysis-classification-example.hbs","poem/prompts/analysis-observation-example.hbs","poem/prompts/analysis-predicate-example.hbs"],"docs":["docs/prd.md#epic-2","docs/architecture.md"]},"additional_notes":"Real-world pattern from SupportSignal: Templates are reusable structures (predicate pattern, classification pattern, observation pattern). Instances are specific implementations (is-violent-incident predicate, is-medication-incident predicate, etc.). Need to decide: 1) Are templates first-class citizens in POEM? 2) Should poem/templates/ be a separate workspace folder? 3) Should templates have schema metadata: {isTemplate: true, templateType: 'predicate'}? 4) Does Epic 2 (prompt authoring) cover this, or is it a gap?"}
